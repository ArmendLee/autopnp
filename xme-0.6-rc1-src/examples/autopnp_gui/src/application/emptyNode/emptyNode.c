/*
 * Copyright (c) 2011-2013, fortiss GmbH.
 * Licensed under the Apache License, Version 2.0.
 *
 * Use, modification and distribution are subject to the terms specified
 * in the accompanying license file LICENSE.txt located at the root directory
 * of this software distribution. A copy is available at
 * http://chromosome.fortiss.org/.
 *
 * This file is part of CHROMOSOME.
 *
 * $Id$
 */

/**
 * \file
 *         Main file of node 'emptyNode'.
 *
 * \author
 *         This file has been generated by the CHROMOSOME Modeling Tool (XMT)
 *         (fortiss GmbH).
 */

/******************************************************************************/
/***   Includes                                                             ***/
/******************************************************************************/
#include "chromosomeGui/adv/componentOne/include/componentOneComponentWrapper.h"
#include "chromosomeGui/adv/componentOne/include/componentOneManifest.h"
#include "chromosomeGui/adv/componentOne/include/doSomethingFunction.h"
#include "chromosomeGui/adv/componentOne/include/doSomethingFunctionWrapper.h"
#include "chromosomeGui/adv/componentOne/include/publishTextFunction.h"
#include "chromosomeGui/adv/componentOne/include/publishTextFunctionWrapper.h"
#include "chromosomeGui/topic/dictionary.h"
#include "xme/core/broker/include/broker.h"
#include "xme/core/broker/include/brokerPnpManagerInterface.h"
#include "xme/core/dataHandler/include/dataHandler.h"
#include "xme/core/executionManager/include/executionManagerScheduleManagementInterface.h"
#include "xme/core/log.h"
#include "xme/core/node.h"
#include "xme/core/topic.h"
#include "xme/hal/include/context.h"
#include "xme/hal/include/mem.h"
#include "xme/hal/include/net.h"
#include "xme/hal/include/sched.h"
#include "xme/hal/include/sharedPtr.h"
#include "xme/hal/include/sync.h"
#include "xme/hal/include/time.h"
#include "xme/hal/include/tls.h"
#include "xme/wp/marshal/include-gen/demarshaler.h"
#include "xme/wp/marshal/include-gen/demarshalerFunctionWrapper.h"
#include "xme/wp/marshal/include-gen/marshaler.h"
#include "xme/wp/marshal/include-gen/marshalerFunctionWrapper.h"
#include "xme/wp/marshal/include/demarshaler.h"
#include "xme/wp/marshal/include/marshaler.h"
#include "xme/wp/udp/include/udpReceive.h"
#include "xme/wp/udp/include/udpReceiveWayPointFunctionWrapper.h"
#include "xme/wp/udp/include/udpSend.h"
#include "xme/wp/udp/include/udpSendWayPointFunctionWrapper.h"

/******************************************************************************/
/***   Static variables                                                     ***/
/******************************************************************************/
/**
 * \brief  Array of all ports on this node.
 *
 * \details Index | Port
 *              0 | componentOne.buttonPushed
 *              1 | componentOne.sendText
 *              2 | demarshaler.configuration[0].in (componentOne.buttonPushed)
 *              3 | demarshaler.configuration[0].out (componentOne.buttonPushed)
 *              4 | udpReceive.configuration[0].out (componentOne.buttonPushed)
 *              5 | marshaler.configuration[0].in (componentOne.sendText)
 *              6 | marshaler.configuration[0].out (componentOne.sendText)
 *              7 | udpSend.configuration[0].in (componentOne.sendText)
 */
static xme_core_dataManager_dataPacketId_t ports[8];

/**
 * \brief  Buffers required by UdpReceiveWaypoint.
 */
static void* recvBuffers[1];
/**
 * \brief  Buffers required by UdpSendWaypoint.
 */
static void* sendBuffers[1];

/******************************************************************************/
/***   Prototypes                                                           ***/
/******************************************************************************/
/**
 * \brief  Initialize CHROMOSOME hal and core components.
 *
 * \retval XME_STATUS_SUCCESS when initialization succeeded without problems.
 * \retval XME_STATUS_OUT_OF_RESOURCES when an error occured during initialization
 *         of one of the core components.
 */
xme_status_t 
xmeInit(void);

/**
 * \brief  Create instance of component 'componentOne'.
 *
 * \details Creates ports, allocates memory for and populates given function descriptor and
 *          registers component  functions at the broker.
 *          If any error occurred during initialization, the given descriptor is set to NULL.
 *
 * \param  doSomethingDescriptor Descriptor for function 'doSomething'.
 * \param  publishTextDescriptor Descriptor for function 'publishText'.
 * \param  componentId Id of this component instance.
 * \param  dataPacketIds Array of data packet ids that will be used for this components ports.
 *         There must be 2 elements in the array.
 *         FIXME: This parameter is only added as a temporary solution for the pnpClient and should be removed as soon as
 *                the pnpClient uses instanceManifests and does not call the main node file anymore.
 *
 * \retval XME_STATUS_SUCCESS When initialization succeded without errors.
 * \retval XME_STATUS_OUT_OF_RESOURCES initialization failure due to insufficient resources.
 * \retval XME_STATUS_INTERNAL_ERROR When an error occured during initialization.
 */
xme_status_t
createComponentOneInstance
(
    xme_core_component_t componentId,
    xme_core_exec_functionDescriptor_t** doSomethingDescriptor,
    xme_core_exec_functionDescriptor_t** publishTextDescriptor,
    xme_core_dataManager_dataPacketId_t* dataPacketIds
);

/**
 * \brief  Create demarshaler waypoint instance.
 *
 * \details Allocates and populates given function descriptor and calls init function of waypoint.
 *          All calls to this function after the first one will do nothing except for setting
 *          the descriptor to the previously allocated one.
 *
 * \param  descriptor Will be set to a pointer to the allocation function descriptor.
 * \param  componentId Component id that will be used in the function descriptor.
 *
 * \retval XME_STATUS_SUCCESS when initialization was succesful.
 * \retval XME_STATUS_OUT_OF_RESOURCES initialization failure due to insufficient resources.
 */
xme_status_t
createDemarshalerWaypointInstance
(
    xme_core_exec_functionDescriptor_t** descriptor,
    xme_core_component_t componentId
);

/**
 * \brief  Adds a configuration entry to the demarshaler waypoint.
 *
 * \details Creates and adds a configuration entry for the demarshaler waypoint.
 *          The required ports are also created.
 *
 * \param  descriptor Function descriptor of this waypoint.
 * \param  inputDataPort Pointer to port id that will be used for the created input port of the configuration.
 * \param  outputDataPort Pointer to port id that will be used for the created output port of the configuration.
 * \param  instanceId Pointer where instanceId of created configuration will be written to.
 * \param  topic Topic for this configuration.
 * \param  topicSize Size of the topic data structure.
 *
 * \retval XME_STATUS_SUCCESS when no errors occurred.
 * \retval XME_STATUS_INTERNAL_ERROR when an error occured.
 */
xme_status_t
demarshalerWaypointAddConfig
(
    xme_core_exec_functionDescriptor_t* descriptor,
    xme_core_dataManager_dataPacketId_t* inputDataPort,
    xme_core_dataManager_dataPacketId_t* outputDataPort,
    xme_wp_waypoint_instanceId_t* instanceId,
    xme_core_topic_t topic,
    uint16_t topicSize
);

/**
 * \brief  Free resources allocated by this waypoint.
 */
void
destroyDemarshalerWaypointInstance
(
    xme_core_exec_functionDescriptor_t* descriptor
);

/**
 * \brief  Create udp receive waypoint instance.
 *
 * \details Allocates and populates given function descriptor and calls init function of waypoint.
 *          All calls to this function after the first one will do nothing except for setting
 *          the descriptor to the previously allocated one.
 *
 * \param  descriptor Will be set to a pointer to the allocation function descriptor.
 * \param  componentId Component id that will be used in the function descriptor.
 *
 * \retval XME_STATUS_SUCCESS when initialization was succesful.
 * \retval XME_STATUS_OUT_OF_RESOURCES initialization failure due to insufficient resources.
 */
xme_status_t
createUdpReceiveWaypointInstance
(
    xme_core_exec_functionDescriptor_t** descriptor,
    xme_core_component_t componentId
);

/**
 * \brief  Adds a configuration entry to the udp receive waypoint.
 *
 * \details Creates and adds configuration structure for udp receive waypoint.
 *          The required port and buffer are also created.
 *
 * \param  descriptor Function descriptor of this waypoint.
 * \param  dataPort Pointer to port id that will be used for the created port of the configuration.
 * \param  key See key parameter of xme_wp_udp_udpReceive_addConfig.
 * \param  ipPort See port parameter of xme_wp_udp_udpReceive_addConfig.
 * \param  topic Topic for this configuration.
 * \param  sizeOfTopic Size of the topic data structure.
 * \param  instanceId See instanceId parameter of xme_wp_udp_udpReceive_addConfig.
 * \param  recvBuffer See buffer parameter of xme_wp_udp_udpReceive_addConfig.
 *
 * \retval XME_STATUS_SUCCESS when no errors occurred.
 * \retval XME_STATUS_INTERNAL_ERROR when an error occured.
 */
xme_status_t
udpReceiveWaypointAddConfig
(
    xme_core_exec_functionDescriptor_t* descriptor,
    xme_core_dataManager_dataPacketId_t* dataPort,
    uint8_t* key,
    uint32_t ipPort,
    xme_core_topic_t topic,
    uint16_t sizeOfTopic,
    xme_wp_waypoint_instanceId_t* instanceId,
    void* recvBuffer
);

/**
 * \brief  Free resources allocated by this waypoint.
 */
void
destroyUdpReceiveWaypointInstance
(
    xme_core_exec_functionDescriptor_t* descriptor
);

/**
 * \brief  Create marshaler waypoint instance.
 *
 * \details Allocates and populates given function descriptor and calls init function of waypoint.
 *          All calls to this function after the first one will do nothing except for setting
 *          the descriptor to the previously allocated one.
 *
 * \param  descriptor Will be set to a pointer to the allocation function descriptor.
 * \param  componentId Component id that will be used in the function descriptor.
 *
 * \retval XME_STATUS_SUCCESS when initialization was succesful.
 * \retval XME_STATUS_OUT_OF_RESOURCES initialization failure due to insufficient resources.
 */
xme_status_t
createMarshalerWaypointInstance
(
    xme_core_exec_functionDescriptor_t** descriptor,
    xme_core_component_t componentId
);

/**
 * \brief  Adds a configuration entry to the marshaler waypoint.
 *
 * \details Creates and adds a configuration entry for the marshaler waypoint.
 *          The required ports are also created.
 *
 * \param  descriptor Function descriptor of this waypoint.
 * \param  inputDataPort Pointer to port id that will be used for the created input port of the configuration.
 * \param  inputDataPort Pointer to port id that will be used for the created output port of the configuration.
 * \param  instanceId Pointer where instanceId of created configuration will be written to.
 * \param  topic Topic for this configuration.
 * \param  topicSize Size of the topic data structure.
 *
 * \retval XME_STATUS_SUCCESS when no errors occurred.
 * \retval XME_STATUS_INTERNAL_ERROR when an error occured.
 */
xme_status_t
marshalerWaypointAddConfig
(
    xme_core_exec_functionDescriptor_t* descriptor,
    xme_core_dataManager_dataPacketId_t* inputDataPort,
    xme_core_dataManager_dataPacketId_t* outputDataPort,
    xme_wp_waypoint_instanceId_t* instanceId,
    xme_core_topic_t topic,
    uint16_t topicSize
);

/**
 * \brief  Free resources allocated by this waypoint.
 */
void
destroyMarshalerWaypointInstance
(
    xme_core_exec_functionDescriptor_t* descriptor
);

/**
 * \brief  Create udp send waypoint instance.
 *
 * \details Allocates and populates given function descriptor and calls init function of waypoint.
 *          All calls to this function after the first one will do nothing except for setting
 *          the descriptor to the previously allocated one.
 *
 * \param  descriptor Will be set to a pointer to the allocation function descriptor.
 * \param  componentId Component id that will be used in the function descriptor.
 *
 * \retval XME_STATUS_SUCCESS when initialization was succesful.
 * \retval XME_STATUS_OUT_OF_RESOURCES initialization failure due to insufficient resources.
 */
xme_status_t
createUdpSendWaypointInstance
(
    xme_core_exec_functionDescriptor_t** descriptor,
    xme_core_component_t componentId
);

/**
 * \brief  Adds a configuration entry to the udp send waypoint.
 *
 * \details Creates and adds configuration structure for udp send waypoint.
 *          The required port and buffer are also created.
 *
 * \param  descriptor Function descriptor of this waypoint.
 * \param  dataPort Pointer to port id that will be used for the created port of the configuration.
 * \param  key See key parameter of xme_wp_udp_udpSend_addConfig.
 * \param  destIP See hostname parameter of xme_wp_udp_udpSend_addConfig.
 * \param  ipPort See port parameter of xme_wp_udp_udpSend_addConfig.
 * \param  topic Topic for this configuration.
 * \param  sizeOfTopic Size of the topic data structure.
 * \param  instanceId See instanceId parameter of xme_wp_udp_udpSend_addConfig.
 * \param  sendBuffer See buffer parameter of xme_wp_udp_udpSend_addConfig.
 *
 * \retval XME_STATUS_SUCCESS when no errors occurred.
 * \retval XME_STATUS_INTERNAL_ERROR when an error occured.
 */
xme_status_t
udpSendWaypointAddConfig
(
    xme_core_exec_functionDescriptor_t* descriptor,
    xme_core_dataManager_dataPacketId_t* dataPort,
    uint8_t* key,
    const char* destIP,
    uint32_t ipPort,
    xme_core_topic_t topic,
    uint16_t sizeOfTopic,
    xme_wp_waypoint_instanceId_t* instanceId,
    void* sendBuffer,
    bool isBroadcast
);

/**
 * \brief  Free resources allocated by this waypoint.
 */
void
destroyUdpSendWaypointInstance
(
    xme_core_exec_functionDescriptor_t* descriptor
);

/**
 * \brief  Frees resources allocated by function.
 *
 * \details Does not call the fini method of the function.
 *          It finalizes the management data structures (descriptor memory,
 *          registrations at broker, ...).
 *
 * \param  descriptor Function to be destroyed.
 */
void
destroyFunction
(
    xme_core_exec_functionDescriptor_t* descriptor
);

/**
 * \brief  Add packet transfer entries for all ports to the broker.
 */
void
addDataPacketTransferEntries(void);

/******************************************************************************/
/***   Implementation                                                       ***/
/******************************************************************************/
xme_status_t
xmeInit(void)
{
    XME_CHECK(XME_STATUS_SUCCESS == xme_hal_sync_init(), XME_STATUS_OUT_OF_RESOURCES);
    XME_CHECK(XME_STATUS_SUCCESS == xme_hal_sched_init(), XME_STATUS_OUT_OF_RESOURCES);
    XME_CHECK(XME_STATUS_SUCCESS == xme_core_directory_attribute_init(), XME_STATUS_OUT_OF_RESOURCES);
    XME_CHECK(XME_STATUS_SUCCESS == xme_core_dataHandler_init(18), XME_STATUS_OUT_OF_RESOURCES);
    {
        xme_core_exec_configStruct_t configStruct = { NULL };
        XME_CHECK(XME_STATUS_SUCCESS == xme_core_exec_init(&configStruct), XME_STATUS_OUT_OF_RESOURCES);
    }
    XME_CHECK(XME_STATUS_SUCCESS == xme_hal_sharedPtr_init(), XME_STATUS_OUT_OF_RESOURCES);
    XME_CHECK(XME_STATUS_SUCCESS == xme_hal_tls_init(), XME_STATUS_OUT_OF_RESOURCES);
    XME_CHECK(XME_STATUS_SUCCESS == xme_hal_context_init(), XME_STATUS_OUT_OF_RESOURCES);
    XME_CHECK(XME_STATUS_SUCCESS == xme_hal_net_init(), XME_STATUS_OUT_OF_RESOURCES);
    XME_CHECK(XME_STATUS_SUCCESS == xme_core_broker_init(NULL), XME_STATUS_OUT_OF_RESOURCES);
    XME_CHECK(XME_STATUS_SUCCESS == xme_core_node_init(), XME_STATUS_OUT_OF_RESOURCES);
    
    // Add interface to node registry
    {
        xme_com_interface_address_t interfaceAddress;
    
        xme_com_interface_ipv4StringToGenericAddress("127.0.0.1:33222", &interfaceAddress);
        xme_core_node_addInterface(interfaceAddress);
    }
    
    xme_core_node_setCurrentNodeId((xme_core_node_nodeId_t) 2);
    
    return XME_STATUS_SUCCESS;
}

xme_status_t
createComponentOneInstance
(
    xme_core_component_t componentId,
    xme_core_exec_functionDescriptor_t** doSomethingDescriptor,
    xme_core_exec_functionDescriptor_t** publishTextDescriptor,
    xme_core_dataManager_dataPacketId_t* dataPacketIds
)
{
    xme_status_t status;
    static uint8_t portCreationStatus = 0; // 0: ports are not created, 1: ports are created, 2: port creation failed
    
    *doSomethingDescriptor = NULL;
    *publishTextDescriptor = NULL;
    
    // When port creation failed in previous calls, all subsequent calls to this function will also fail
    if (2 == portCreationStatus)
    {
        XME_CHECK_MSG
        (
            2 != portCreationStatus,
            XME_STATUS_INTERNAL_ERROR,
            XME_LOG_ERROR,
            "%s:%d Creation of new instance of component type 'componentOne' fails, because creation of ports failed previously.",
            __FILE__,
            __LINE__
        );
    }
    
    if (0 == portCreationStatus)
    {
        portCreationStatus = 2;
        
        // Create input port 'buttonPushed'
        {
            xme_core_attribute_descriptor_list_t metadata;
            xme_core_attribute_descriptor_t metadataElements[1];
            metadataElements[0].key = (xme_core_attribute_key_t) 0;
            metadataElements[0].size = (size_t) 0;
            metadata.length = 1;
            metadata.element = metadataElements;
        
            status = xme_core_dataHandler_createPort
            (
                componentId,
                XME_CORE_COMPONENT_PORTTYPE_DCC_SUBSCRIPTION,
                CHROMOSOMEGUI_TOPIC_BUTTONSIGNAL,
                sizeof(chromosomeGui_topic_ButtonSignal_t),
                metadata,
                1,
                false,
                false,
                0,
                &dataPacketIds[0]
            );
            XME_CHECK_MSG
            (
                XME_STATUS_SUCCESS == status,
                status,
                XME_LOG_ERROR,
                "%s:%d Creation of port failed with status %d.\n",
                __FILE__,
                __LINE__,
                status
            );
        }
        
        // Create output port 'sendText'
        {
            xme_core_attribute_descriptor_list_t metadata;
            xme_core_attribute_descriptor_t metadataElements[1];
            metadataElements[0].key = (xme_core_attribute_key_t) 0;
            metadataElements[0].size = (size_t) 0;
            metadata.length = 1;
            metadata.element = metadataElements;
        
            status = xme_core_dataHandler_createPort
            (
                componentId,
                XME_CORE_COMPONENT_PORTTYPE_DCC_PUBLICATION,
                CHROMOSOMEGUI_TOPIC_WRITETEXT,
                sizeof(chromosomeGui_topic_WriteText_t),
                metadata,
                1,
                false,
                false,
                0,
                &dataPacketIds[1]
            );
            XME_CHECK_MSG
            (
                XME_STATUS_SUCCESS == status,
                status,
                XME_LOG_ERROR,
                "%s:%d Creation of port failed with status %d.\n",
                __FILE__,
                __LINE__,
                status
            );
        }
        
        // Set ports in component wrapper
        status = chromosomeGui_adv_componentOne_componentOneComponentWrapper_receivePort
        (
            dataPacketIds[0],
            CHROMOSOMEGUI_ADV_COMPONENTONE_COMPONENTONECOMPONENTWRAPPER_PORT_BUTTONPUSHED
        );
        XME_CHECK_MSG
        (
            XME_STATUS_SUCCESS == status,
            status,
            XME_LOG_ERROR,
            "%s:%d receivePort failed with status %d.\n",
            __FILE__,
            __LINE__,
            status
        );
        
        status = chromosomeGui_adv_componentOne_componentOneComponentWrapper_receivePort
        (
            dataPacketIds[1],
            CHROMOSOMEGUI_ADV_COMPONENTONE_COMPONENTONECOMPONENTWRAPPER_PORT_SENDTEXT
        );
        XME_CHECK_MSG
        (
            XME_STATUS_SUCCESS == status,
            status,
            XME_LOG_ERROR,
            "%s:%d receivePort failed with status %d.\n",
            __FILE__,
            __LINE__,
            status
        );
        
            
        portCreationStatus = 1;
    }
    
    // Allocate and initialize descriptor for function 'doSomething'
    *doSomethingDescriptor = (xme_core_exec_functionDescriptor_t*)
            xme_hal_mem_alloc(sizeof(xme_core_exec_functionDescriptor_t));
    XME_CHECK_MSG
    (
        NULL != *doSomethingDescriptor,
        XME_STATUS_OUT_OF_RESOURCES,
        XME_LOG_ERROR,
        "%s:%d Allocation of function descriptor failed.\n",
        __FILE__,
        __LINE__
    );
    xme_hal_mem_set(*doSomethingDescriptor, 0, sizeof(xme_core_exec_functionDescriptor_t));
    (*doSomethingDescriptor)->task = (xme_hal_sched_taskCallback_t)
            (&chromosomeGui_adv_componentOne_doSomethingFunctionWrapper_execute);
    (*doSomethingDescriptor)->taskArgs = (void*)(*doSomethingDescriptor);
    (*doSomethingDescriptor)->componentId = componentId;
    (*doSomethingDescriptor)->functionId = (xme_core_component_functionId_t) 1;
    (*doSomethingDescriptor)->init = &chromosomeGui_adv_componentOne_doSomethingFunction_init;
    (*doSomethingDescriptor)->initParam = xme_hal_mem_alloc(sizeof(xme_maxSystemValue_t));
    XME_CHECK_MSG_REC
    (
        NULL != (*doSomethingDescriptor)->initParam,
        XME_STATUS_OUT_OF_RESOURCES,
        {
        },
        XME_LOG_ERROR,
        "%s:%d Allocation of initial Parameters for the init function failed.\n",
        __FILE__,
        __LINE__
    );
    (*doSomethingDescriptor)->fini = &chromosomeGui_adv_componentOne_doSomethingFunction_fini;
    (*doSomethingDescriptor)->wcet_ns = xme_hal_time_timeIntervalFromMilliseconds(200);
    
    // Register with broker
    status = xme_core_broker_registerFunction
    (
        (*doSomethingDescriptor)->componentId,
        (*doSomethingDescriptor)->functionId,
        (*doSomethingDescriptor)
    );
    XME_CHECK_MSG_REC
    (
        XME_STATUS_INVALID_PARAMETER != status && XME_STATUS_UNEXPECTED != status,
        status,
        {
        },
        XME_LOG_WARNING,
        "%s:%d Registeration with broker failed with status %d.\n",
        __FILE__,
        __LINE__,
        status
    );
    
    status = xme_core_broker_addDataPacketToFunction
    (
        dataPacketIds[0],
        (*doSomethingDescriptor)->componentId,
        (*doSomethingDescriptor)->functionId,
        (*doSomethingDescriptor),
        true
    );
    XME_CHECK_MSG_REC
    (
        XME_STATUS_INVALID_PARAMETER != status && XME_STATUS_UNEXPECTED != status,
        status,
        {
        },
        XME_LOG_WARNING,
        "%s:%d Addition of data packet to broker failed with status %d.\n",
        __FILE__,
        __LINE__,
        status
    );
    
    
    
    // Allocate and initialize descriptor for function 'publishText'
    *publishTextDescriptor = (xme_core_exec_functionDescriptor_t*)
            xme_hal_mem_alloc(sizeof(xme_core_exec_functionDescriptor_t));
    XME_CHECK_MSG_REC
    (
        NULL != *publishTextDescriptor,
        XME_STATUS_OUT_OF_RESOURCES,
        {
            xme_hal_mem_free(*doSomethingDescriptor);
            doSomethingDescriptor = NULL;
        },
        XME_LOG_ERROR,
        "%s:%d Allocation of function descriptor failed.\n",
        __FILE__,
        __LINE__
    );
    xme_hal_mem_set(*publishTextDescriptor, 0, sizeof(xme_core_exec_functionDescriptor_t));
    (*publishTextDescriptor)->task = (xme_hal_sched_taskCallback_t)
            (&chromosomeGui_adv_componentOne_publishTextFunctionWrapper_execute);
    (*publishTextDescriptor)->taskArgs = (void*)(*publishTextDescriptor);
    (*publishTextDescriptor)->componentId = componentId;
    (*publishTextDescriptor)->functionId = (xme_core_component_functionId_t) 2;
    (*publishTextDescriptor)->init = &chromosomeGui_adv_componentOne_publishTextFunction_init;
    (*publishTextDescriptor)->initParam = xme_hal_mem_alloc(sizeof(xme_maxSystemValue_t));
    XME_CHECK_MSG_REC
    (
        NULL != (*publishTextDescriptor)->initParam,
        XME_STATUS_OUT_OF_RESOURCES,
        {
            xme_hal_mem_free(*doSomethingDescriptor);
            doSomethingDescriptor = NULL;
        },
        XME_LOG_ERROR,
        "%s:%d Allocation of initial Parameters for the init function failed.\n",
        __FILE__,
        __LINE__
    );
    (*publishTextDescriptor)->fini = &chromosomeGui_adv_componentOne_publishTextFunction_fini;
    (*publishTextDescriptor)->wcet_ns = xme_hal_time_timeIntervalFromMilliseconds(200);
    
    // Register with broker
    status = xme_core_broker_registerFunction
    (
        (*publishTextDescriptor)->componentId,
        (*publishTextDescriptor)->functionId,
        (*publishTextDescriptor)
    );
    XME_CHECK_MSG_REC
    (
        XME_STATUS_INVALID_PARAMETER != status && XME_STATUS_UNEXPECTED != status,
        status,
        {
            xme_hal_mem_free(*doSomethingDescriptor);
            doSomethingDescriptor = NULL;
        },
        XME_LOG_WARNING,
        "%s:%d Registeration with broker failed with status %d.\n",
        __FILE__,
        __LINE__,
        status
    );
    
    
    return XME_STATUS_SUCCESS;
}

xme_status_t
createDemarshalerWaypointInstance
(
    xme_core_exec_functionDescriptor_t** descriptor,
    xme_core_component_t componentId
)
{
    static xme_core_exec_functionDescriptor_t* desc = NULL;

    if (NULL == desc)
    {
        desc = (xme_core_exec_functionDescriptor_t*)
                xme_hal_mem_alloc(sizeof(xme_core_exec_functionDescriptor_t));
        XME_CHECK_MSG
        (
            NULL != desc,
            XME_STATUS_OUT_OF_RESOURCES,
            XME_LOG_ERROR,
            "%s:%d Allocation of function Descriptor failed.\n",
            __FILE__,
            __LINE__
        );
        xme_hal_mem_set(desc, 0, sizeof(xme_core_exec_functionDescriptor_t));
        desc->task = (xme_hal_sched_taskCallback_t)
                &(xme_wp_marshal_demarshalerFunctionWrapper_execute);
        desc->taskArgs = desc;
        desc->componentId = componentId;
        desc->functionId = (xme_core_component_functionId_t) 1;
        desc->wcet_ns = xme_hal_time_timeIntervalFromMilliseconds(50);
        
        xme_core_exec_dispatcher_createFunctionExecutionUnit(desc, true);
        
        xme_wp_marshal_demarshaler_init();
    }
    
    *descriptor = desc;
    
    return XME_STATUS_SUCCESS;
}

xme_status_t
demarshalerWaypointAddConfig
(
    xme_core_exec_functionDescriptor_t* descriptor,
    xme_core_dataManager_dataPacketId_t* inputDataPort,
    xme_core_dataManager_dataPacketId_t* outputDataPort,
    xme_wp_waypoint_instanceId_t* instanceId,
    xme_core_topic_t topic,
    uint16_t topicSize
)
{
    xme_status_t status;
    
    // Create subscription port
    {
        xme_core_attribute_descriptor_list_t metadata;
        xme_core_attribute_descriptor_t metadata_elements[1];
        metadata_elements[0].key = (xme_core_attribute_key_t) 0;
        metadata_elements[0].size = (size_t) 0;
        metadata.length = 1;
        metadata.element = metadata_elements;
    
        status = xme_core_dataHandler_createPort
        (
            descriptor->componentId,
            XME_CORE_COMPONENT_PORTTYPE_DCC_SUBSCRIPTION,
            topic,
            topicSize,
            metadata,
            1,
            false,
            false,
            0,
            inputDataPort
        );
        XME_CHECK_MSG
        (
            XME_STATUS_SUCCESS == status,
            XME_STATUS_INTERNAL_ERROR,
            XME_LOG_ERROR,
            "%s:%d Creation of port failed.\n",
            __FILE__,
            __LINE__
        );
    }
    
    // Create publication port
    {
        xme_core_attribute_descriptor_list_t metadata;
        xme_core_attribute_descriptor_t metadata_elements[1];
        metadata_elements[0].key = (xme_core_attribute_key_t) 0;
        metadata_elements[0].size = (size_t) 0;
        metadata.length = 1;
        metadata.element = metadata_elements;
    
        status = xme_core_dataHandler_createPort
        (
            descriptor->componentId,
            XME_CORE_COMPONENT_PORTTYPE_DCC_PUBLICATION,
            topic,
            topicSize,
            metadata,
            1,
            false,
            false,
            0,
            outputDataPort
        );
        XME_CHECK_MSG
        (
            XME_STATUS_SUCCESS == status,
            XME_STATUS_INTERNAL_ERROR,
            XME_LOG_ERROR,
            "%s:%d Creation of port failed.\n",
            __FILE__,
            __LINE__
        );
    }
    
    // Add waypoint configuration
    {
        xme_wp_marshal_demarshaler_addConfig
        (
            instanceId,
            topic,
            *inputDataPort,
            *outputDataPort
        );
    }
    
    // Register with broker
    status = xme_core_broker_registerFunction
    (
        descriptor->componentId,
        descriptor->functionId,
        (xme_core_component_functionVariantId_t)(*instanceId)
    );
    XME_CHECK_MSG
    (
        XME_STATUS_INVALID_PARAMETER != status && XME_STATUS_UNEXPECTED != status,
        status,
        XME_LOG_WARNING,
        "%s:%d Registeration with broker failed.\n",
        __FILE__,
        __LINE__
    );
    
    status = xme_core_broker_addDataPacketToFunction
    (
        *inputDataPort,
        descriptor->componentId,
        descriptor->functionId,
        (xme_core_component_functionVariantId_t)(*instanceId),
        true
    );
    XME_CHECK_MSG
    (
        XME_STATUS_INVALID_PARAMETER != status && XME_STATUS_UNEXPECTED != status,
        status,
        XME_LOG_WARNING,
        "%s:%d Addition of data packet to broker failed.\n",
        __FILE__,
        __LINE__
    );    
    
    return XME_STATUS_SUCCESS;
}

void
destroyDemarshalerWaypointInstance
(
    xme_core_exec_functionDescriptor_t* descriptor
)
{
    xme_core_broker_removeFunction
    (
        descriptor->componentId,
        descriptor->functionId
    );
    xme_hal_mem_free(descriptor->initParam);
    xme_hal_mem_free(descriptor);
}

xme_status_t
createUdpReceiveWaypointInstance
(
    xme_core_exec_functionDescriptor_t** descriptor,
    xme_core_component_t componentId
)
{
    static xme_core_exec_functionDescriptor_t* desc = NULL;

    if (NULL == desc)
    {
        desc = (xme_core_exec_functionDescriptor_t*)
                xme_hal_mem_alloc(sizeof(xme_core_exec_functionDescriptor_t));
        XME_CHECK_MSG
        (
            NULL != desc,
            XME_STATUS_OUT_OF_RESOURCES,
            XME_LOG_ERROR,
            "%s:%d Allocation of function Descriptor failed.\n",
            __FILE__,
            __LINE__
        );
        xme_hal_mem_set(desc, 0, sizeof(xme_core_exec_functionDescriptor_t));
        desc->task = (xme_hal_sched_taskCallback_t)
                &(xme_wp_udp_udpReceive_udpReceiveWayPointFunctionWrapper_execute);
        desc->taskArgs = desc;
        desc->componentId = componentId;
        desc->functionId = (xme_core_component_functionId_t) 1;
        desc->wcet_ns = xme_hal_time_timeIntervalFromMilliseconds(50);
        
        xme_core_exec_dispatcher_createFunctionExecutionUnit(desc, true);
        
        xme_wp_udp_udpReceive_init();
    }
    
    *descriptor = desc;
    
    return XME_STATUS_SUCCESS;
}

xme_status_t
udpReceiveWaypointAddConfig
(
    xme_core_exec_functionDescriptor_t* descriptor,
    xme_core_dataManager_dataPacketId_t* dataPort,
    uint8_t* key,
    uint32_t ipPort,
    xme_core_topic_t topic,
    uint16_t sizeOfTopic,
    xme_wp_waypoint_instanceId_t* instanceId,
    void* recvBuffer
)
{
    xme_status_t status;
    
    // Create publication
    {
        xme_core_attribute_descriptor_list_t metadata;
        xme_core_attribute_descriptor_t metadata_elements[1];
        metadata_elements[0].key = (xme_core_attribute_key_t) 0;
        metadata_elements[0].size = (size_t) 0;
        metadata.length = 1;
        metadata.element = metadata_elements;
    
        status = xme_core_dataHandler_createPort
        (
            descriptor->componentId,
            XME_CORE_COMPONENT_PORTTYPE_DCC_PUBLICATION,
            topic,
            sizeOfTopic,
            metadata,
            1,
            false,
            false,
            0,
            dataPort
        );
        XME_CHECK_MSG
        (
            XME_STATUS_SUCCESS == status,
            XME_STATUS_INTERNAL_ERROR,
            XME_LOG_ERROR,
            "%s:%d Creation of port failed.\n",
            __FILE__,
            __LINE__
        );
    }
    
    // Add waypoint configuration
    {
        uint16_t bufferSize;
        
        bufferSize = sizeOfTopic + xme_wp_udp_udpReceive_getPackageOverHead();
        
        recvBuffer = xme_hal_mem_alloc(bufferSize);
        XME_CHECK_MSG
        (
            NULL != recvBuffer,
            XME_STATUS_INTERNAL_ERROR,
            XME_LOG_ERROR,
            "%s:%d Allocation of buffer failed.\n",
            __FILE__,
            __LINE__
        );
        
        status = xme_wp_udp_udpReceive_addConfig
        (
            instanceId,
            *dataPort,
            sizeOfTopic,
            recvBuffer,
            bufferSize,
            key,
            ipPort
        );
        XME_CHECK_MSG
        (
            XME_STATUS_SUCCESS == status,
            XME_STATUS_INTERNAL_ERROR,
            XME_LOG_ERROR,
            "%s:%d udpReceive addConfig failed.\n",
            __FILE__,
            __LINE__
        );
    }
    
    // Register with broker
    status = xme_core_broker_registerFunction
    (
        descriptor->componentId,
        descriptor->functionId,
        (xme_core_component_functionVariantId_t)(*instanceId)
    );
    XME_CHECK_MSG
    (
        XME_STATUS_INVALID_PARAMETER != status && XME_STATUS_UNEXPECTED != status,
        status,
        XME_LOG_WARNING,
        "%s:%d Registeration with broker failed.\n",
        __FILE__,
        __LINE__
    );
    
    return XME_STATUS_SUCCESS;
}

void
destroyUdpReceiveWaypointInstance
(
    xme_core_exec_functionDescriptor_t* descriptor
)
{
    uint8_t i;
    
    // Free allocated buffers
    for (i = 0; i < sizeof(recvBuffers)/sizeof(recvBuffers[0]); i++)
    {
        xme_hal_mem_free(recvBuffers[i]);
    }
    
    xme_core_broker_removeFunction
    (
        descriptor->componentId,
        descriptor->functionId
    );
    xme_hal_mem_free(descriptor->initParam);
    xme_hal_mem_free(descriptor);
}

xme_status_t
createMarshalerWaypointInstance
(
    xme_core_exec_functionDescriptor_t** descriptor,
    xme_core_component_t componentId
)
{
    static xme_core_exec_functionDescriptor_t* desc = NULL;

    if (NULL == desc)
    {
        desc = (xme_core_exec_functionDescriptor_t*)
                xme_hal_mem_alloc(sizeof(xme_core_exec_functionDescriptor_t));
        XME_CHECK_MSG
        (
            NULL != desc,
            XME_STATUS_OUT_OF_RESOURCES,
            XME_LOG_ERROR,
            "%s:%d Allocation of function Descriptor failed.\n",
            __FILE__,
            __LINE__
        );
        xme_hal_mem_set(desc, 0, sizeof(xme_core_exec_functionDescriptor_t));
        desc->task = (xme_hal_sched_taskCallback_t)
                &(xme_wp_marshal_marshalerFunctionWrapper_execute);
        desc->taskArgs = desc;
        desc->componentId = componentId;
        desc->functionId = (xme_core_component_functionId_t) 1;
        desc->wcet_ns = xme_hal_time_timeIntervalFromMilliseconds(50);
        
        xme_core_exec_dispatcher_createFunctionExecutionUnit(desc, true);
        
        xme_wp_marshal_marshaler_init();
    }
    
    *descriptor = desc;
    
    return XME_STATUS_SUCCESS;
}

xme_status_t
marshalerWaypointAddConfig
(
    xme_core_exec_functionDescriptor_t* descriptor,
    xme_core_dataManager_dataPacketId_t* inputDataPort,
    xme_core_dataManager_dataPacketId_t* outputDataPort,
    xme_wp_waypoint_instanceId_t* instanceId,
    xme_core_topic_t topic,
    uint16_t topicSize
)
{
    xme_status_t status;
    
    // Create subscription port
    {
        xme_core_attribute_descriptor_list_t metadata;
        xme_core_attribute_descriptor_t metadata_elements[1];
        metadata_elements[0].key = (xme_core_attribute_key_t) 0;
        metadata_elements[0].size = (size_t) 0;
        metadata.length = 1;
        metadata.element = metadata_elements;
    
        status = xme_core_dataHandler_createPort
        (
            descriptor->componentId,
            XME_CORE_COMPONENT_PORTTYPE_DCC_SUBSCRIPTION,
            topic,
            topicSize,
            metadata,
            1,
            false,
            false,
            0,
            inputDataPort
        );
        XME_CHECK_MSG
        (
            XME_STATUS_SUCCESS == status,
            XME_STATUS_INTERNAL_ERROR,
            XME_LOG_ERROR,
            "%s:%d Creation of port failed.\n",
            __FILE__,
            __LINE__
        );
    }
    
    // Create publication port
    {
        xme_core_attribute_descriptor_list_t metadata;
        xme_core_attribute_descriptor_t metadata_elements[1];
        metadata_elements[0].key = (xme_core_attribute_key_t) 0;
        metadata_elements[0].size = (size_t) 0;
        metadata.length = 1;
        metadata.element = metadata_elements;
    
        status = xme_core_dataHandler_createPort
        (
            descriptor->componentId,
            XME_CORE_COMPONENT_PORTTYPE_DCC_PUBLICATION,
            topic,
            topicSize,
            metadata,
            1,
            false,
            false,
            0,
            outputDataPort
        );
        XME_CHECK_MSG
        (
            XME_STATUS_SUCCESS == status,
            XME_STATUS_INTERNAL_ERROR,
            XME_LOG_ERROR,
            "%s:%d Creation of port failed.\n",
            __FILE__,
            __LINE__
        );
    }
    
    // Add waypoint configuration
    {
        xme_wp_marshal_marshaler_addConfig
        (
            instanceId,
            topic,
            *inputDataPort,
            *outputDataPort
        );
    }
    
    // Register with broker
    status = xme_core_broker_registerFunction
    (
            descriptor->componentId,
            descriptor->functionId,
            (xme_core_component_functionVariantId_t)(*instanceId)
    );
    XME_CHECK_MSG
    (
        XME_STATUS_INVALID_PARAMETER != status || XME_STATUS_UNEXPECTED != status,
        status,
        XME_LOG_WARNING,
        "%s:%d Registeration with broker failed.\n",
        __FILE__,
        __LINE__
    );
    
    status = xme_core_broker_addDataPacketToFunction
    (
            *inputDataPort,
            descriptor->componentId,
            descriptor->functionId,
            (xme_core_component_functionVariantId_t)(*instanceId),
            true
    );
    XME_CHECK_MSG
    (
        XME_STATUS_INVALID_PARAMETER != status || XME_STATUS_UNEXPECTED != status,
        status,
        XME_LOG_WARNING,
        "%s:%d Addition of data packet to broker failed.\n",
        __FILE__,
        __LINE__
    );
    
    return XME_STATUS_SUCCESS;
}

void
destroyMarshalerWaypointInstance
(
    xme_core_exec_functionDescriptor_t* descriptor
)
{
    xme_core_broker_removeFunction
    (
        descriptor->componentId,
        descriptor->functionId
    );
    xme_hal_mem_free(descriptor->initParam);
    xme_hal_mem_free(descriptor);
}

xme_status_t
createUdpSendWaypointInstance
(
    xme_core_exec_functionDescriptor_t** descriptor,
    xme_core_component_t componentId
)
{
    static xme_core_exec_functionDescriptor_t* desc = NULL;

    if (NULL == desc)
    {
        desc = (xme_core_exec_functionDescriptor_t*)
                xme_hal_mem_alloc(sizeof(xme_core_exec_functionDescriptor_t));
        XME_CHECK_MSG
        (
            NULL != desc,
            XME_STATUS_OUT_OF_RESOURCES,
            XME_LOG_ERROR,
            "%s:%d Allocation of function Descriptor failed.\n",
            __FILE__,
            __LINE__
        );
        xme_hal_mem_set(desc, 0, sizeof(xme_core_exec_functionDescriptor_t));
        desc->task = (xme_hal_sched_taskCallback_t)
                &(xme_wp_udp_udpSend_udpSendWayPointFunctionWrapper_execute);
        desc->taskArgs = desc;
        desc->componentId = componentId;
        desc->functionId = (xme_core_component_functionId_t) 1;
        desc->wcet_ns = xme_hal_time_timeIntervalFromMilliseconds(50);
        
        xme_wp_udp_udpSend_init();
        
        xme_core_exec_dispatcher_createFunctionExecutionUnit(desc, true);
    }
    
    *descriptor = desc;
    
    return XME_STATUS_SUCCESS;
}

xme_status_t
udpSendWaypointAddConfig
(
    xme_core_exec_functionDescriptor_t* descriptor,
    xme_core_dataManager_dataPacketId_t* dataPort,
    uint8_t* key,
    const char* destIP,
    uint32_t ipPort,
    xme_core_topic_t topic,
    uint16_t sizeOfTopic,
    xme_wp_waypoint_instanceId_t* instanceId,
    void* sendBuffer,
    bool isBroadcast
)
{
    xme_status_t status;
    
    // Create subscription
    {
        xme_core_attribute_descriptor_list_t metadata;
        xme_core_attribute_descriptor_t metadata_elements[1];
        metadata_elements[0].key = (xme_core_attribute_key_t) 0;
        metadata_elements[0].size = (size_t) 0;
        metadata.length = 1;
        metadata.element = metadata_elements;
    
        status = xme_core_dataHandler_createPort
        (
            descriptor->componentId,
            XME_CORE_COMPONENT_PORTTYPE_DCC_SUBSCRIPTION,
            topic,
            sizeOfTopic,
            metadata,
            1,
            false,
            false,
            0,
            dataPort
        );
        XME_CHECK_MSG
        (
            XME_STATUS_SUCCESS == status,
            XME_STATUS_INTERNAL_ERROR,
            XME_LOG_ERROR,
            "%s:%d Creation of port failed.\n",
            __FILE__,
            __LINE__
        );
    }
    
    // Add waypoint configuration
    {
        uint16_t bufferSize;
        
        bufferSize = sizeOfTopic + xme_wp_udp_udpSend_getPackageOverHead();
        sendBuffer = xme_hal_mem_alloc(bufferSize);
        XME_CHECK_MSG
        (
            NULL != sendBuffer,
            XME_STATUS_INTERNAL_ERROR,
            XME_LOG_ERROR,
            "%s:%d Allocation of buffer failed.\n",
            __FILE__,
            __LINE__
        );
        
        status = xme_wp_udp_udpSend_addConfig
        (
            instanceId,
            *dataPort,
            sizeOfTopic,
            sendBuffer,
            bufferSize,
            key,
            destIP,
            ipPort,
            isBroadcast
        );
        XME_CHECK_MSG
        (
            XME_STATUS_SUCCESS == status,
            XME_STATUS_INTERNAL_ERROR,
            XME_LOG_ERROR,
            "%s:%d udpSend addConfig failed.\n",
            __FILE__,
            __LINE__
        );
    }
    
    // Register with broker
    status = xme_core_broker_registerFunction
    (
        descriptor->componentId,
        descriptor->functionId,
        (xme_core_component_functionVariantId_t)(*instanceId)
    );
    XME_CHECK_MSG
    (
        XME_STATUS_INVALID_PARAMETER != status && XME_STATUS_UNEXPECTED != status,
        status,
        XME_LOG_WARNING,
        "%s:%d Registeration with broker failed.\n",
        __FILE__,
        __LINE__
    );
    
    status = xme_core_broker_addDataPacketToFunction
    (
        *dataPort,
        descriptor->componentId,
        descriptor->functionId,
        (xme_core_component_functionVariantId_t)(*instanceId),
        true
    );
    XME_CHECK_MSG
    (
        XME_STATUS_INVALID_PARAMETER != status && XME_STATUS_UNEXPECTED != status,
        status,
        XME_LOG_WARNING,
        "%s:%d Addition of data packet to broker failed.\n",
        __FILE__,
        __LINE__
    );
    
    return XME_STATUS_SUCCESS;
}

void
destroyUdpSendWaypointInstance
(
    xme_core_exec_functionDescriptor_t* descriptor
)
{
    uint8_t i;
    
    
    // Free allocated buffers
    for (i = 0; i < sizeof(sendBuffers)/sizeof(sendBuffers[0]); i++)
    {
        xme_hal_mem_free(sendBuffers[i]);
    }
    xme_core_broker_removeFunction
    (
        descriptor->componentId,
        descriptor->functionId
    );
    xme_hal_mem_free(descriptor->initParam);
    xme_hal_mem_free(descriptor);
}


void
destroyFunction
(
    xme_core_exec_functionDescriptor_t* descriptor
)
{
    xme_core_broker_removeFunction
    (
        descriptor->componentId,
        descriptor->functionId
    );
    xme_hal_mem_free(descriptor->initParam);
    xme_hal_mem_free(descriptor);
}

void
addDataPacketTransferEntries(void)
{
    xme_core_broker_addDataPacketTransferEntry(ports[3], ports[0]); // demarshaler.configuration[0].out (componentOne.buttonPushed) -> componentOne.buttonPushed
    xme_core_broker_addDataPacketTransferEntry(ports[4], ports[2]); // udpReceive.configuration[0].out (componentOne.buttonPushed) -> demarshaler.configuration[0].in (componentOne.buttonPushed)
    xme_core_broker_addDataPacketTransferEntry(ports[1], ports[5]); // componentOne.sendText -> marshaler.configuration[0].in (componentOne.sendText)
    xme_core_broker_addDataPacketTransferEntry(ports[6], ports[7]); // marshaler.configuration[0].out (componentOne.sendText) -> udpSend.configuration[0].in (componentOne.sendText)
}

int
main(int argc, char* argv[])
{
    xme_status_t status;
    xme_core_exec_schedule_handle_t scheduleId;
    xme_core_exec_schedule_table_t* nodeSchedules[1];
    xme_core_exec_functionDescriptor_t* componentOneDoSomethingDesc = NULL;
    xme_core_exec_functionDescriptor_t* componentOnePublishTextDesc = NULL;
    xme_core_exec_functionDescriptor_t* demarshalerWaypointDescriptor = NULL;
    xme_wp_waypoint_instanceId_t demarshalerWaypointInstanceIds[1];
    xme_core_exec_functionDescriptor_t* udpReceiveWaypointDescriptor = NULL;
    xme_wp_waypoint_instanceId_t udpReceiveWaypointInstanceIds[1];
    xme_core_exec_functionDescriptor_t* marshalerWaypointDescriptor = NULL;
    xme_wp_waypoint_instanceId_t marshalerWaypointInstanceIds[1];
    xme_core_exec_functionDescriptor_t* udpSendWaypointDescriptor = NULL;
    xme_wp_waypoint_instanceId_t udpSendWaypointInstanceIds[1];

    XME_UNUSED_PARAMETER(argc);
    XME_UNUSED_PARAMETER(argv);

    status = xmeInit();
    XME_CHECK_MSG
    (
        XME_STATUS_SUCCESS == status,
        status,
        XME_LOG_FATAL,
        "Error occurred during initialization of CHROMOSOME core components. Aborting execution."
    );
    
    // Create component instances
    
    // Component instance 'componentOne' of type 'componentOne'
    createComponentOneInstance
    (
        (xme_core_component_t)1,
        &componentOneDoSomethingDesc,
        &componentOnePublishTextDesc,
        &ports[0] // componentOne.buttonPushed
    );
    
    // Add waypoint configurations
    createDemarshalerWaypointInstance
    (
        &demarshalerWaypointDescriptor,
        (xme_core_component_t)2
    );
    
    {
        if (NULL != demarshalerWaypointDescriptor)
        {
            demarshalerWaypointAddConfig
            (
                demarshalerWaypointDescriptor,
                &ports[2], // demarshaler.configuration[0].in (componentOne.buttonPushed)
                &ports[3], // demarshaler.configuration[0].out (componentOne.buttonPushed)
                &demarshalerWaypointInstanceIds[0],
                CHROMOSOMEGUI_TOPIC_BUTTONSIGNAL,
                sizeof(chromosomeGui_topic_ButtonSignal_t)
            );
        }
    }
    createUdpReceiveWaypointInstance
    (
        &udpReceiveWaypointDescriptor,
        (xme_core_component_t)3
    );
    
    {
        // Add configurations
        if (NULL != udpReceiveWaypointDescriptor)
        {
            {
                uint8_t key[] = {0, 0, 16, 2};
            
                udpReceiveWaypointAddConfig
                (
                    udpReceiveWaypointDescriptor,
                    &ports[4], // udpReceive.configuration[0].out (componentOne.buttonPushed)
                    key,
                    33222,
                    CHROMOSOMEGUI_TOPIC_BUTTONSIGNAL,
                    sizeof(chromosomeGui_topic_ButtonSignal_t),
                    &udpReceiveWaypointInstanceIds[0],
                    recvBuffers[0]
                );
            }
        }
    }
    createMarshalerWaypointInstance
    (
        &marshalerWaypointDescriptor,
        (xme_core_component_t)4
    );
    
    {
        // Add configurations
        if (NULL != marshalerWaypointDescriptor)
        {
            marshalerWaypointAddConfig
            (
                marshalerWaypointDescriptor,
                &ports[5], // marshaler.configuration[0].in (componentOne.sendText)
                &ports[6], // marshaler.configuration[0].out (componentOne.sendText)
                &marshalerWaypointInstanceIds[0],
                CHROMOSOMEGUI_TOPIC_WRITETEXT,
                sizeof(chromosomeGui_topic_WriteText_t)
            );
        }
    }
    createUdpSendWaypointInstance
    (
        &udpSendWaypointDescriptor,
        (xme_core_component_t)5
    );
    
    {
        // Add configurations
        if (NULL != udpSendWaypointDescriptor)
        {
            {
                uint8_t key[] = {0, 0, 16, 3};
            
                udpSendWaypointAddConfig
                (
                    udpSendWaypointDescriptor,
                    &ports[7], // udpSend.configuration[0].in (componentOne.sendText)
                    key,
                    "127.0.0.1",
                    33221,
                    CHROMOSOMEGUI_TOPIC_WRITETEXT,
                    sizeof(chromosomeGui_topic_WriteText_t),
                    &udpSendWaypointInstanceIds[0],
                    sendBuffers[0],
                    false
                );
            }
        }
    }

    addDataPacketTransferEntries();

    // Execution Manager and Scheduler

    // Configure dispatcher
    if (NULL != componentOneDoSomethingDesc)
    {
        status = xme_core_exec_dispatcher_createFunctionExecutionUnit(componentOneDoSomethingDesc, true);
        XME_ASSERT(XME_STATUS_SUCCESS == status);
    }
    if (NULL != componentOnePublishTextDesc)
    {
        status = xme_core_exec_dispatcher_createFunctionExecutionUnit(componentOnePublishTextDesc, true);
        XME_ASSERT(XME_STATUS_SUCCESS == status);
    }

    // Configure schedule
    xme_core_exec_scheduler_createScheduleTable
    (
        &(nodeSchedules[0]),
        xme_hal_time_timeIntervalFromMilliseconds(1600)
    );

    if (NULL != componentOnePublishTextDesc)
    {
        // Add function 'publishText' of component instance 'componentOne' of type 'componentOne' to schedule
        status = xme_core_exec_scheduler_addElementToScheduleTable
        (
            nodeSchedules[0],
            componentOnePublishTextDesc->componentId,
            componentOnePublishTextDesc->functionId,
            componentOnePublishTextDesc->taskArgs,
            xme_hal_time_timeIntervalFromSeconds(0),
            xme_hal_time_timeIntervalFromMilliseconds(200),
            1,
            0,
            true
        );
        XME_ASSERT(XME_STATUS_SUCCESS == status);
    }
    if (NULL != marshalerWaypointDescriptor)
    {
        // Add marshaler waypoint configuration for component port 'componentOne.sendText'to schedule
        status = xme_core_exec_scheduler_addElementToScheduleTable
        (
            nodeSchedules[0],
            marshalerWaypointDescriptor->componentId,
            marshalerWaypointDescriptor->functionId,
            (void *)(uintptr_t)marshalerWaypointInstanceIds[0],
            xme_hal_time_timeIntervalFromMilliseconds(200),
            xme_hal_time_timeIntervalFromMilliseconds(50),
            1,
            0,
            true
        );
        XME_ASSERT(XME_STATUS_SUCCESS == status);
    }
    if (NULL != udpSendWaypointDescriptor)
    {
        // Add udpsend waypoint configuration for component port 'componentOne.sendText'to schedule
        status = xme_core_exec_scheduler_addElementToScheduleTable
        (
            nodeSchedules[0],
            udpSendWaypointDescriptor->componentId,
            udpSendWaypointDescriptor->functionId,
            (void *)(uintptr_t)udpSendWaypointInstanceIds[0],
            xme_hal_time_timeIntervalFromMilliseconds(250),
            xme_hal_time_timeIntervalFromMilliseconds(50),
            1,
            0,
            true
        );
        XME_ASSERT(XME_STATUS_SUCCESS == status);
    }
    if (NULL != udpReceiveWaypointDescriptor)
    {
        // Add udpreceive waypoint configuration for component port 'componentOne.buttonPushed'to schedule
        status = xme_core_exec_scheduler_addElementToScheduleTable
        (
            nodeSchedules[0],
            udpReceiveWaypointDescriptor->componentId,
            udpReceiveWaypointDescriptor->functionId,
            (void *)(uintptr_t)udpReceiveWaypointInstanceIds[0],
            xme_hal_time_timeIntervalFromMilliseconds(300),
            xme_hal_time_timeIntervalFromMilliseconds(50),
            1,
            0,
            true
        );
        XME_ASSERT(XME_STATUS_SUCCESS == status);
    }
    if (NULL != demarshalerWaypointDescriptor)
    {
        // Add demarshaler waypoint configuration for component port 'componentOne.buttonPushed'to schedule
        status = xme_core_exec_scheduler_addElementToScheduleTable
        (
            nodeSchedules[0],
            demarshalerWaypointDescriptor->componentId,
            demarshalerWaypointDescriptor->functionId,
            (void *)(uintptr_t)demarshalerWaypointInstanceIds[0],
            xme_hal_time_timeIntervalFromMilliseconds(350),
            xme_hal_time_timeIntervalFromMilliseconds(50),
            1,
            0,
            true
        );
        XME_ASSERT(XME_STATUS_SUCCESS == status);
    }
    if (NULL != componentOneDoSomethingDesc)
    {
        // Add function 'doSomething' of component instance 'componentOne' of type 'componentOne' to schedule
        status = xme_core_exec_scheduler_addElementToScheduleTable
        (
            nodeSchedules[0],
            componentOneDoSomethingDesc->componentId,
            componentOneDoSomethingDesc->functionId,
            componentOneDoSomethingDesc->taskArgs,
            xme_hal_time_timeIntervalFromMilliseconds(400),
            xme_hal_time_timeIntervalFromMilliseconds(200),
            1,
            0,
            true
        );
        XME_ASSERT(XME_STATUS_SUCCESS == status);
    }

    status = xme_core_exec_scheduler_registerSchedule(nodeSchedules[0], &scheduleId);
    XME_ASSERT(XME_STATUS_SUCCESS == status);

    // Activate schedule
    xme_core_exec_scheduler_activateSchedule(scheduleId);

    // Run the schedule
    xme_core_exec_run(0, false);
    xme_core_exec_fini();

    // Destroy waypoints
    if (NULL != demarshalerWaypointDescriptor)
    {
        destroyDemarshalerWaypointInstance(demarshalerWaypointDescriptor);
    }
    if (NULL != udpReceiveWaypointDescriptor)
    {
        destroyUdpReceiveWaypointInstance(udpReceiveWaypointDescriptor);
    }
    if (NULL != marshalerWaypointDescriptor)
    {
        destroyMarshalerWaypointInstance(marshalerWaypointDescriptor);
    }
    if (NULL != udpSendWaypointDescriptor)
    {
        destroyUdpSendWaypointInstance(udpSendWaypointDescriptor);
    }
    
    // Destroy components
    destroyFunction(componentOneDoSomethingDesc);
    destroyFunction(componentOnePublishTextDesc);

    return 0;
}
