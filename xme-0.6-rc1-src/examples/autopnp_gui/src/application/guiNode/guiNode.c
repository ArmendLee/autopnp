/*
 * Copyright (c) 2011-2013, fortiss GmbH.
 * Licensed under the Apache License, Version 2.0.
 *
 * Use, modification and distribution are subject to the terms specified
 * in the accompanying license file LICENSE.txt located at the root directory
 * of this software distribution. A copy is available at
 * http://chromosome.fortiss.org/.
 *
 * This file is part of CHROMOSOME.
 *
 * $Id$
 */

/**
 * \file
 *         Main file of node 'guiNode'.
 *
 * \author
 *         This file has been generated by the CHROMOSOME Modeling Tool (XMT)
 *         (fortiss GmbH).
 */

/******************************************************************************/
/***   Includes                                                             ***/
/******************************************************************************/
#include "chromosomeGui/adv/guiComponent/include/guiComponentComponentWrapper.h"
#include "chromosomeGui/adv/guiComponent/include/guiComponentManifest.h"
#include "chromosomeGui/adv/guiComponent/include/sendButtonStateFunction.h"
#include "chromosomeGui/adv/guiComponent/include/sendButtonStateFunctionWrapper.h"
#include "chromosomeGui/adv/guiComponent/include/writeTextFunction.h"
#include "chromosomeGui/adv/guiComponent/include/writeTextFunctionWrapper.h"
#include "chromosomeGui/topic/dictionary.h"
#include "xme/core/broker/include/broker.h"
#include "xme/core/broker/include/brokerPnpManagerInterface.h"
#include "xme/core/dataHandler/include/dataHandler.h"
#include "xme/core/executionManager/include/executionManagerScheduleManagementInterface.h"
#include "xme/core/log.h"
#include "xme/core/node.h"
#include "xme/core/topic.h"
#include "xme/hal/include/context.h"
#include "xme/hal/include/mem.h"
#include "xme/hal/include/net.h"
#include "xme/hal/include/sched.h"
#include "xme/hal/include/sharedPtr.h"
#include "xme/hal/include/sync.h"
#include "xme/hal/include/time.h"
#include "xme/hal/include/tls.h"
#include "xme/wp/marshal/include-gen/demarshaler.h"
#include "xme/wp/marshal/include-gen/demarshalerFunctionWrapper.h"
#include "xme/wp/marshal/include-gen/marshaler.h"
#include "xme/wp/marshal/include-gen/marshalerFunctionWrapper.h"
#include "xme/wp/marshal/include/demarshaler.h"
#include "xme/wp/marshal/include/marshaler.h"
#include "xme/wp/udp/include/udpReceive.h"
#include "xme/wp/udp/include/udpReceiveWayPointFunctionWrapper.h"
#include "xme/wp/udp/include/udpSend.h"
#include "xme/wp/udp/include/udpSendWayPointFunctionWrapper.h"

/******************************************************************************/
/***   Static variables                                                     ***/
/******************************************************************************/
/**
 * \brief  Array of all ports on this node.
 *
 * \details Index | Port
 *              0 | guiComponent.writeText
 *              1 | guiComponent.buttonPushed
 *              2 | demarshaler.configuration[0].in (guiComponent.writeText)
 *              3 | demarshaler.configuration[0].out (guiComponent.writeText)
 *              4 | udpReceive.configuration[0].out (guiComponent.writeText)
 *              5 | marshaler.configuration[0].in (guiComponent.buttonPushed)
 *              6 | marshaler.configuration[0].out (guiComponent.buttonPushed)
 *              7 | udpSend.configuration[0].in (guiComponent.buttonPushed)
 */
static xme_core_dataManager_dataPacketId_t ports[8];

/**
 * \brief  Buffers required by UdpReceiveWaypoint.
 */
static void* recvBuffers[1];
/**
 * \brief  Buffers required by UdpSendWaypoint.
 */
static void* sendBuffers[1];

/******************************************************************************/
/***   Prototypes                                                           ***/
/******************************************************************************/
/**
 * \brief  Initialize CHROMOSOME hal and core components.
 *
 * \retval XME_STATUS_SUCCESS when initialization succeeded without problems.
 * \retval XME_STATUS_OUT_OF_RESOURCES when an error occured during initialization
 *         of one of the core components.
 */
xme_status_t 
xmeInit(void);

/**
 * \brief  Create instance of component 'guiComponent'.
 *
 * \details Creates ports, allocates memory for and populates given function descriptor and
 *          registers component  functions at the broker.
 *          If any error occurred during initialization, the given descriptor is set to NULL.
 *
 * \param  writeTextDescriptor Descriptor for function 'writeText'.
 * \param  sendButtonStateDescriptor Descriptor for function 'sendButtonState'.
 * \param  componentId Id of this component instance.
 * \param  dataPacketIds Array of data packet ids that will be used for this components ports.
 *         There must be 2 elements in the array.
 *         FIXME: This parameter is only added as a temporary solution for the pnpClient and should be removed as soon as
 *                the pnpClient uses instanceManifests and does not call the main node file anymore.
 *
 * \retval XME_STATUS_SUCCESS When initialization succeded without errors.
 * \retval XME_STATUS_OUT_OF_RESOURCES initialization failure due to insufficient resources.
 * \retval XME_STATUS_INTERNAL_ERROR When an error occured during initialization.
 */
xme_status_t
createGuiComponentInstance
(
    xme_core_component_t componentId,
    xme_core_exec_functionDescriptor_t** writeTextDescriptor,
    xme_core_exec_functionDescriptor_t** sendButtonStateDescriptor,
    xme_core_dataManager_dataPacketId_t* dataPacketIds
);

/**
 * \brief  Create demarshaler waypoint instance.
 *
 * \details Allocates and populates given function descriptor and calls init function of waypoint.
 *          All calls to this function after the first one will do nothing except for setting
 *          the descriptor to the previously allocated one.
 *
 * \param  descriptor Will be set to a pointer to the allocation function descriptor.
 * \param  componentId Component id that will be used in the function descriptor.
 *
 * \retval XME_STATUS_SUCCESS when initialization was succesful.
 * \retval XME_STATUS_OUT_OF_RESOURCES initialization failure due to insufficient resources.
 */
xme_status_t
createDemarshalerWaypointInstance
(
    xme_core_exec_functionDescriptor_t** descriptor,
    xme_core_component_t componentId
);

/**
 * \brief  Adds a configuration entry to the demarshaler waypoint.
 *
 * \details Creates and adds a configuration entry for the demarshaler waypoint.
 *          The required ports are also created.
 *
 * \param  descriptor Function descriptor of this waypoint.
 * \param  inputDataPort Pointer to port id that will be used for the created input port of the configuration.
 * \param  outputDataPort Pointer to port id that will be used for the created output port of the configuration.
 * \param  instanceId Pointer where instanceId of created configuration will be written to.
 * \param  topic Topic for this configuration.
 * \param  topicSize Size of the topic data structure.
 *
 * \retval XME_STATUS_SUCCESS when no errors occurred.
 * \retval XME_STATUS_INTERNAL_ERROR when an error occured.
 */
xme_status_t
demarshalerWaypointAddConfig
(
    xme_core_exec_functionDescriptor_t* descriptor,
    xme_core_dataManager_dataPacketId_t* inputDataPort,
    xme_core_dataManager_dataPacketId_t* outputDataPort,
    xme_wp_waypoint_instanceId_t* instanceId,
    xme_core_topic_t topic,
    uint16_t topicSize
);

/**
 * \brief  Free resources allocated by this waypoint.
 */
void
destroyDemarshalerWaypointInstance
(
    xme_core_exec_functionDescriptor_t* descriptor
);

/**
 * \brief  Create udp receive waypoint instance.
 *
 * \details Allocates and populates given function descriptor and calls init function of waypoint.
 *          All calls to this function after the first one will do nothing except for setting
 *          the descriptor to the previously allocated one.
 *
 * \param  descriptor Will be set to a pointer to the allocation function descriptor.
 * \param  componentId Component id that will be used in the function descriptor.
 *
 * \retval XME_STATUS_SUCCESS when initialization was succesful.
 * \retval XME_STATUS_OUT_OF_RESOURCES initialization failure due to insufficient resources.
 */
xme_status_t
createUdpReceiveWaypointInstance
(
    xme_core_exec_functionDescriptor_t** descriptor,
    xme_core_component_t componentId
);

/**
 * \brief  Adds a configuration entry to the udp receive waypoint.
 *
 * \details Creates and adds configuration structure for udp receive waypoint.
 *          The required port and buffer are also created.
 *
 * \param  descriptor Function descriptor of this waypoint.
 * \param  dataPort Pointer to port id that will be used for the created port of the configuration.
 * \param  key See key parameter of xme_wp_udp_udpReceive_addConfig.
 * \param  ipPort See port parameter of xme_wp_udp_udpReceive_addConfig.
 * \param  topic Topic for this configuration.
 * \param  sizeOfTopic Size of the topic data structure.
 * \param  instanceId See instanceId parameter of xme_wp_udp_udpReceive_addConfig.
 * \param  recvBuffer See buffer parameter of xme_wp_udp_udpReceive_addConfig.
 *
 * \retval XME_STATUS_SUCCESS when no errors occurred.
 * \retval XME_STATUS_INTERNAL_ERROR when an error occured.
 */
xme_status_t
udpReceiveWaypointAddConfig
(
    xme_core_exec_functionDescriptor_t* descriptor,
    xme_core_dataManager_dataPacketId_t* dataPort,
    uint8_t* key,
    uint32_t ipPort,
    xme_core_topic_t topic,
    uint16_t sizeOfTopic,
    xme_wp_waypoint_instanceId_t* instanceId,
    void* recvBuffer
);

/**
 * \brief  Free resources allocated by this waypoint.
 */
void
destroyUdpReceiveWaypointInstance
(
    xme_core_exec_functionDescriptor_t* descriptor
);

/**
 * \brief  Create marshaler waypoint instance.
 *
 * \details Allocates and populates given function descriptor and calls init function of waypoint.
 *          All calls to this function after the first one will do nothing except for setting
 *          the descriptor to the previously allocated one.
 *
 * \param  descriptor Will be set to a pointer to the allocation function descriptor.
 * \param  componentId Component id that will be used in the function descriptor.
 *
 * \retval XME_STATUS_SUCCESS when initialization was succesful.
 * \retval XME_STATUS_OUT_OF_RESOURCES initialization failure due to insufficient resources.
 */
xme_status_t
createMarshalerWaypointInstance
(
    xme_core_exec_functionDescriptor_t** descriptor,
    xme_core_component_t componentId
);

/**
 * \brief  Adds a configuration entry to the marshaler waypoint.
 *
 * \details Creates and adds a configuration entry for the marshaler waypoint.
 *          The required ports are also created.
 *
 * \param  descriptor Function descriptor of this waypoint.
 * \param  inputDataPort Pointer to port id that will be used for the created input port of the configuration.
 * \param  inputDataPort Pointer to port id that will be used for the created output port of the configuration.
 * \param  instanceId Pointer where instanceId of created configuration will be written to.
 * \param  topic Topic for this configuration.
 * \param  topicSize Size of the topic data structure.
 *
 * \retval XME_STATUS_SUCCESS when no errors occurred.
 * \retval XME_STATUS_INTERNAL_ERROR when an error occured.
 */
xme_status_t
marshalerWaypointAddConfig
(
    xme_core_exec_functionDescriptor_t* descriptor,
    xme_core_dataManager_dataPacketId_t* inputDataPort,
    xme_core_dataManager_dataPacketId_t* outputDataPort,
    xme_wp_waypoint_instanceId_t* instanceId,
    xme_core_topic_t topic,
    uint16_t topicSize
);

/**
 * \brief  Free resources allocated by this waypoint.
 */
void
destroyMarshalerWaypointInstance
(
    xme_core_exec_functionDescriptor_t* descriptor
);

/**
 * \brief  Create udp send waypoint instance.
 *
 * \details Allocates and populates given function descriptor and calls init function of waypoint.
 *          All calls to this function after the first one will do nothing except for setting
 *          the descriptor to the previously allocated one.
 *
 * \param  descriptor Will be set to a pointer to the allocation function descriptor.
 * \param  componentId Component id that will be used in the function descriptor.
 *
 * \retval XME_STATUS_SUCCESS when initialization was succesful.
 * \retval XME_STATUS_OUT_OF_RESOURCES initialization failure due to insufficient resources.
 */
xme_status_t
createUdpSendWaypointInstance
(
    xme_core_exec_functionDescriptor_t** descriptor,
    xme_core_component_t componentId
);

/**
 * \brief  Adds a configuration entry to the udp send waypoint.
 *
 * \details Creates and adds configuration structure for udp send waypoint.
 *          The required port and buffer are also created.
 *
 * \param  descriptor Function descriptor of this waypoint.
 * \param  dataPort Pointer to port id that will be used for the created port of the configuration.
 * \param  key See key parameter of xme_wp_udp_udpSend_addConfig.
 * \param  destIP See hostname parameter of xme_wp_udp_udpSend_addConfig.
 * \param  ipPort See port parameter of xme_wp_udp_udpSend_addConfig.
 * \param  topic Topic for this configuration.
 * \param  sizeOfTopic Size of the topic data structure.
 * \param  instanceId See instanceId parameter of xme_wp_udp_udpSend_addConfig.
 * \param  sendBuffer See buffer parameter of xme_wp_udp_udpSend_addConfig.
 *
 * \retval XME_STATUS_SUCCESS when no errors occurred.
 * \retval XME_STATUS_INTERNAL_ERROR when an error occured.
 */
xme_status_t
udpSendWaypointAddConfig
(
    xme_core_exec_functionDescriptor_t* descriptor,
    xme_core_dataManager_dataPacketId_t* dataPort,
    uint8_t* key,
    const char* destIP,
    uint32_t ipPort,
    xme_core_topic_t topic,
    uint16_t sizeOfTopic,
    xme_wp_waypoint_instanceId_t* instanceId,
    void* sendBuffer,
    bool isBroadcast
);

/**
 * \brief  Free resources allocated by this waypoint.
 */
void
destroyUdpSendWaypointInstance
(
    xme_core_exec_functionDescriptor_t* descriptor
);

/**
 * \brief  Frees resources allocated by function.
 *
 * \details Does not call the fini method of the function.
 *          It finalizes the management data structures (descriptor memory,
 *          registrations at broker, ...).
 *
 * \param  descriptor Function to be destroyed.
 */
void
destroyFunction
(
    xme_core_exec_functionDescriptor_t* descriptor
);

/**
 * \brief  Add packet transfer entries for all ports to the broker.
 */
void
addDataPacketTransferEntries(void);

/******************************************************************************/
/***   Implementation                                                       ***/
/******************************************************************************/
xme_status_t
xmeInit(void)
{
    XME_CHECK(XME_STATUS_SUCCESS == xme_hal_sync_init(), XME_STATUS_OUT_OF_RESOURCES);
    XME_CHECK(XME_STATUS_SUCCESS == xme_hal_sched_init(), XME_STATUS_OUT_OF_RESOURCES);
    XME_CHECK(XME_STATUS_SUCCESS == xme_core_directory_attribute_init(), XME_STATUS_OUT_OF_RESOURCES);
    XME_CHECK(XME_STATUS_SUCCESS == xme_core_dataHandler_init(18), XME_STATUS_OUT_OF_RESOURCES);
    {
        xme_core_exec_configStruct_t configStruct = { NULL };
        XME_CHECK(XME_STATUS_SUCCESS == xme_core_exec_init(&configStruct), XME_STATUS_OUT_OF_RESOURCES);
    }
    XME_CHECK(XME_STATUS_SUCCESS == xme_hal_sharedPtr_init(), XME_STATUS_OUT_OF_RESOURCES);
    XME_CHECK(XME_STATUS_SUCCESS == xme_hal_tls_init(), XME_STATUS_OUT_OF_RESOURCES);
    XME_CHECK(XME_STATUS_SUCCESS == xme_hal_context_init(), XME_STATUS_OUT_OF_RESOURCES);
    XME_CHECK(XME_STATUS_SUCCESS == xme_hal_net_init(), XME_STATUS_OUT_OF_RESOURCES);
    XME_CHECK(XME_STATUS_SUCCESS == xme_core_broker_init(NULL), XME_STATUS_OUT_OF_RESOURCES);
    XME_CHECK(XME_STATUS_SUCCESS == xme_core_node_init(), XME_STATUS_OUT_OF_RESOURCES);
    
    // Add interface to node registry
    {
        xme_com_interface_address_t interfaceAddress;
    
        xme_com_interface_ipv4StringToGenericAddress("127.0.0.1:33221", &interfaceAddress);
        xme_core_node_addInterface(interfaceAddress);
    }
    
    xme_core_node_setCurrentNodeId((xme_core_node_nodeId_t) 3);
    
    return XME_STATUS_SUCCESS;
}

xme_status_t
createGuiComponentInstance
(
    xme_core_component_t componentId,
    xme_core_exec_functionDescriptor_t** writeTextDescriptor,
    xme_core_exec_functionDescriptor_t** sendButtonStateDescriptor,
    xme_core_dataManager_dataPacketId_t* dataPacketIds
)
{
    xme_status_t status;
    static uint8_t portCreationStatus = 0; // 0: ports are not created, 1: ports are created, 2: port creation failed
    
    *writeTextDescriptor = NULL;
    *sendButtonStateDescriptor = NULL;
    
    // When port creation failed in previous calls, all subsequent calls to this function will also fail
    if (2 == portCreationStatus)
    {
        XME_CHECK_MSG
        (
            2 != portCreationStatus,
            XME_STATUS_INTERNAL_ERROR,
            XME_LOG_ERROR,
            "%s:%d Creation of new instance of component type 'guiComponent' fails, because creation of ports failed previously.",
            __FILE__,
            __LINE__
        );
    }
    
    if (0 == portCreationStatus)
    {
        portCreationStatus = 2;
        
        // Create input port 'writeText'
        {
            xme_core_attribute_descriptor_list_t metadata;
            xme_core_attribute_descriptor_t metadataElements[1];
            metadataElements[0].key = (xme_core_attribute_key_t) 0;
            metadataElements[0].size = (size_t) 0;
            metadata.length = 1;
            metadata.element = metadataElements;
        
            status = xme_core_dataHandler_createPort
            (
                componentId,
                XME_CORE_COMPONENT_PORTTYPE_DCC_SUBSCRIPTION,
                CHROMOSOMEGUI_TOPIC_WRITETEXT,
                sizeof(chromosomeGui_topic_WriteText_t),
                metadata,
                1,
                false,
                false,
                0,
                &dataPacketIds[0]
            );
            XME_CHECK_MSG
            (
                XME_STATUS_SUCCESS == status,
                status,
                XME_LOG_ERROR,
                "%s:%d Creation of port failed with status %d.\n",
                __FILE__,
                __LINE__,
                status
            );
        }
        
        // Create output port 'buttonPushed'
        {
            xme_core_attribute_descriptor_list_t metadata;
            xme_core_attribute_descriptor_t metadataElements[1];
            metadataElements[0].key = (xme_core_attribute_key_t) 0;
            metadataElements[0].size = (size_t) 0;
            metadata.length = 1;
            metadata.element = metadataElements;
        
            status = xme_core_dataHandler_createPort
            (
                componentId,
                XME_CORE_COMPONENT_PORTTYPE_DCC_PUBLICATION,
                CHROMOSOMEGUI_TOPIC_BUTTONSIGNAL,
                sizeof(chromosomeGui_topic_ButtonSignal_t),
                metadata,
                1,
                false,
                false,
                0,
                &dataPacketIds[1]
            );
            XME_CHECK_MSG
            (
                XME_STATUS_SUCCESS == status,
                status,
                XME_LOG_ERROR,
                "%s:%d Creation of port failed with status %d.\n",
                __FILE__,
                __LINE__,
                status
            );
        }
        
        // Set ports in component wrapper
        status = chromosomeGui_adv_guiComponent_guiComponentComponentWrapper_receivePort
        (
            dataPacketIds[0],
            CHROMOSOMEGUI_ADV_GUICOMPONENT_GUICOMPONENTCOMPONENTWRAPPER_PORT_WRITETEXT
        );
        XME_CHECK_MSG
        (
            XME_STATUS_SUCCESS == status,
            status,
            XME_LOG_ERROR,
            "%s:%d receivePort failed with status %d.\n",
            __FILE__,
            __LINE__,
            status
        );
        
        status = chromosomeGui_adv_guiComponent_guiComponentComponentWrapper_receivePort
        (
            dataPacketIds[1],
            CHROMOSOMEGUI_ADV_GUICOMPONENT_GUICOMPONENTCOMPONENTWRAPPER_PORT_BUTTONPUSHED
        );
        XME_CHECK_MSG
        (
            XME_STATUS_SUCCESS == status,
            status,
            XME_LOG_ERROR,
            "%s:%d receivePort failed with status %d.\n",
            __FILE__,
            __LINE__,
            status
        );
        
            
        portCreationStatus = 1;
    }
    
    // Allocate and initialize descriptor for function 'writeText'
    *writeTextDescriptor = (xme_core_exec_functionDescriptor_t*)
            xme_hal_mem_alloc(sizeof(xme_core_exec_functionDescriptor_t));
    XME_CHECK_MSG
    (
        NULL != *writeTextDescriptor,
        XME_STATUS_OUT_OF_RESOURCES,
        XME_LOG_ERROR,
        "%s:%d Allocation of function descriptor failed.\n",
        __FILE__,
        __LINE__
    );
    xme_hal_mem_set(*writeTextDescriptor, 0, sizeof(xme_core_exec_functionDescriptor_t));
    (*writeTextDescriptor)->task = (xme_hal_sched_taskCallback_t)
            (&chromosomeGui_adv_guiComponent_writeTextFunctionWrapper_execute);
    (*writeTextDescriptor)->taskArgs = (void*)(*writeTextDescriptor);
    (*writeTextDescriptor)->componentId = componentId;
    (*writeTextDescriptor)->functionId = (xme_core_component_functionId_t) 1;
    (*writeTextDescriptor)->init = &chromosomeGui_adv_guiComponent_writeTextFunction_init;
    (*writeTextDescriptor)->initParam = xme_hal_mem_alloc(sizeof(xme_maxSystemValue_t));
    XME_CHECK_MSG_REC
    (
        NULL != (*writeTextDescriptor)->initParam,
        XME_STATUS_OUT_OF_RESOURCES,
        {
        },
        XME_LOG_ERROR,
        "%s:%d Allocation of initial Parameters for the init function failed.\n",
        __FILE__,
        __LINE__
    );
    (*writeTextDescriptor)->fini = &chromosomeGui_adv_guiComponent_writeTextFunction_fini;
    (*writeTextDescriptor)->wcet_ns = xme_hal_time_timeIntervalFromMilliseconds(200);
    
    // Register with broker
    status = xme_core_broker_registerFunction
    (
        (*writeTextDescriptor)->componentId,
        (*writeTextDescriptor)->functionId,
        (*writeTextDescriptor)
    );
    XME_CHECK_MSG_REC
    (
        XME_STATUS_INVALID_PARAMETER != status && XME_STATUS_UNEXPECTED != status,
        status,
        {
        },
        XME_LOG_WARNING,
        "%s:%d Registeration with broker failed with status %d.\n",
        __FILE__,
        __LINE__,
        status
    );
    
    status = xme_core_broker_addDataPacketToFunction
    (
        dataPacketIds[0],
        (*writeTextDescriptor)->componentId,
        (*writeTextDescriptor)->functionId,
        (*writeTextDescriptor),
        true
    );
    XME_CHECK_MSG_REC
    (
        XME_STATUS_INVALID_PARAMETER != status && XME_STATUS_UNEXPECTED != status,
        status,
        {
        },
        XME_LOG_WARNING,
        "%s:%d Addition of data packet to broker failed with status %d.\n",
        __FILE__,
        __LINE__,
        status
    );
    
    
    
    // Allocate and initialize descriptor for function 'sendButtonState'
    *sendButtonStateDescriptor = (xme_core_exec_functionDescriptor_t*)
            xme_hal_mem_alloc(sizeof(xme_core_exec_functionDescriptor_t));
    XME_CHECK_MSG_REC
    (
        NULL != *sendButtonStateDescriptor,
        XME_STATUS_OUT_OF_RESOURCES,
        {
            xme_hal_mem_free(*writeTextDescriptor);
            writeTextDescriptor = NULL;
        },
        XME_LOG_ERROR,
        "%s:%d Allocation of function descriptor failed.\n",
        __FILE__,
        __LINE__
    );
    xme_hal_mem_set(*sendButtonStateDescriptor, 0, sizeof(xme_core_exec_functionDescriptor_t));
    (*sendButtonStateDescriptor)->task = (xme_hal_sched_taskCallback_t)
            (&chromosomeGui_adv_guiComponent_sendButtonStateFunctionWrapper_execute);
    (*sendButtonStateDescriptor)->taskArgs = (void*)(*sendButtonStateDescriptor);
    (*sendButtonStateDescriptor)->componentId = componentId;
    (*sendButtonStateDescriptor)->functionId = (xme_core_component_functionId_t) 2;
    (*sendButtonStateDescriptor)->init = &chromosomeGui_adv_guiComponent_sendButtonStateFunction_init;
    (*sendButtonStateDescriptor)->initParam = xme_hal_mem_alloc(sizeof(xme_maxSystemValue_t));
    XME_CHECK_MSG_REC
    (
        NULL != (*sendButtonStateDescriptor)->initParam,
        XME_STATUS_OUT_OF_RESOURCES,
        {
            xme_hal_mem_free(*writeTextDescriptor);
            writeTextDescriptor = NULL;
        },
        XME_LOG_ERROR,
        "%s:%d Allocation of initial Parameters for the init function failed.\n",
        __FILE__,
        __LINE__
    );
    (*sendButtonStateDescriptor)->fini = &chromosomeGui_adv_guiComponent_sendButtonStateFunction_fini;
    (*sendButtonStateDescriptor)->wcet_ns = xme_hal_time_timeIntervalFromMilliseconds(200);
    
    // Register with broker
    status = xme_core_broker_registerFunction
    (
        (*sendButtonStateDescriptor)->componentId,
        (*sendButtonStateDescriptor)->functionId,
        (*sendButtonStateDescriptor)
    );
    XME_CHECK_MSG_REC
    (
        XME_STATUS_INVALID_PARAMETER != status && XME_STATUS_UNEXPECTED != status,
        status,
        {
            xme_hal_mem_free(*writeTextDescriptor);
            writeTextDescriptor = NULL;
        },
        XME_LOG_WARNING,
        "%s:%d Registeration with broker failed with status %d.\n",
        __FILE__,
        __LINE__,
        status
    );
    
    
    return XME_STATUS_SUCCESS;
}

xme_status_t
createDemarshalerWaypointInstance
(
    xme_core_exec_functionDescriptor_t** descriptor,
    xme_core_component_t componentId
)
{
    static xme_core_exec_functionDescriptor_t* desc = NULL;

    if (NULL == desc)
    {
        desc = (xme_core_exec_functionDescriptor_t*)
                xme_hal_mem_alloc(sizeof(xme_core_exec_functionDescriptor_t));
        XME_CHECK_MSG
        (
            NULL != desc,
            XME_STATUS_OUT_OF_RESOURCES,
            XME_LOG_ERROR,
            "%s:%d Allocation of function Descriptor failed.\n",
            __FILE__,
            __LINE__
        );
        xme_hal_mem_set(desc, 0, sizeof(xme_core_exec_functionDescriptor_t));
        desc->task = (xme_hal_sched_taskCallback_t)
                &(xme_wp_marshal_demarshalerFunctionWrapper_execute);
        desc->taskArgs = desc;
        desc->componentId = componentId;
        desc->functionId = (xme_core_component_functionId_t) 1;
        desc->wcet_ns = xme_hal_time_timeIntervalFromMilliseconds(50);
        
        xme_core_exec_dispatcher_createFunctionExecutionUnit(desc, true);
        
        xme_wp_marshal_demarshaler_init();
    }
    
    *descriptor = desc;
    
    return XME_STATUS_SUCCESS;
}

xme_status_t
demarshalerWaypointAddConfig
(
    xme_core_exec_functionDescriptor_t* descriptor,
    xme_core_dataManager_dataPacketId_t* inputDataPort,
    xme_core_dataManager_dataPacketId_t* outputDataPort,
    xme_wp_waypoint_instanceId_t* instanceId,
    xme_core_topic_t topic,
    uint16_t topicSize
)
{
    xme_status_t status;
    
    // Create subscription port
    {
        xme_core_attribute_descriptor_list_t metadata;
        xme_core_attribute_descriptor_t metadata_elements[1];
        metadata_elements[0].key = (xme_core_attribute_key_t) 0;
        metadata_elements[0].size = (size_t) 0;
        metadata.length = 1;
        metadata.element = metadata_elements;
    
        status = xme_core_dataHandler_createPort
        (
            descriptor->componentId,
            XME_CORE_COMPONENT_PORTTYPE_DCC_SUBSCRIPTION,
            topic,
            topicSize,
            metadata,
            1,
            false,
            false,
            0,
            inputDataPort
        );
        XME_CHECK_MSG
        (
            XME_STATUS_SUCCESS == status,
            XME_STATUS_INTERNAL_ERROR,
            XME_LOG_ERROR,
            "%s:%d Creation of port failed.\n",
            __FILE__,
            __LINE__
        );
    }
    
    // Create publication port
    {
        xme_core_attribute_descriptor_list_t metadata;
        xme_core_attribute_descriptor_t metadata_elements[1];
        metadata_elements[0].key = (xme_core_attribute_key_t) 0;
        metadata_elements[0].size = (size_t) 0;
        metadata.length = 1;
        metadata.element = metadata_elements;
    
        status = xme_core_dataHandler_createPort
        (
            descriptor->componentId,
            XME_CORE_COMPONENT_PORTTYPE_DCC_PUBLICATION,
            topic,
            topicSize,
            metadata,
            1,
            false,
            false,
            0,
            outputDataPort
        );
        XME_CHECK_MSG
        (
            XME_STATUS_SUCCESS == status,
            XME_STATUS_INTERNAL_ERROR,
            XME_LOG_ERROR,
            "%s:%d Creation of port failed.\n",
            __FILE__,
            __LINE__
        );
    }
    
    // Add waypoint configuration
    {
        xme_wp_marshal_demarshaler_addConfig
        (
            instanceId,
            topic,
            *inputDataPort,
            *outputDataPort
        );
    }
    
    // Register with broker
    status = xme_core_broker_registerFunction
    (
        descriptor->componentId,
        descriptor->functionId,
        (xme_core_component_functionVariantId_t)(*instanceId)
    );
    XME_CHECK_MSG
    (
        XME_STATUS_INVALID_PARAMETER != status && XME_STATUS_UNEXPECTED != status,
        status,
        XME_LOG_WARNING,
        "%s:%d Registeration with broker failed.\n",
        __FILE__,
        __LINE__
    );
    
    status = xme_core_broker_addDataPacketToFunction
    (
        *inputDataPort,
        descriptor->componentId,
        descriptor->functionId,
        (xme_core_component_functionVariantId_t)(*instanceId),
        true
    );
    XME_CHECK_MSG
    (
        XME_STATUS_INVALID_PARAMETER != status && XME_STATUS_UNEXPECTED != status,
        status,
        XME_LOG_WARNING,
        "%s:%d Addition of data packet to broker failed.\n",
        __FILE__,
        __LINE__
    );    
    
    return XME_STATUS_SUCCESS;
}

void
destroyDemarshalerWaypointInstance
(
    xme_core_exec_functionDescriptor_t* descriptor
)
{
    xme_core_broker_removeFunction
    (
        descriptor->componentId,
        descriptor->functionId
    );
    xme_hal_mem_free(descriptor->initParam);
    xme_hal_mem_free(descriptor);
}

xme_status_t
createUdpReceiveWaypointInstance
(
    xme_core_exec_functionDescriptor_t** descriptor,
    xme_core_component_t componentId
)
{
    static xme_core_exec_functionDescriptor_t* desc = NULL;

    if (NULL == desc)
    {
        desc = (xme_core_exec_functionDescriptor_t*)
                xme_hal_mem_alloc(sizeof(xme_core_exec_functionDescriptor_t));
        XME_CHECK_MSG
        (
            NULL != desc,
            XME_STATUS_OUT_OF_RESOURCES,
            XME_LOG_ERROR,
            "%s:%d Allocation of function Descriptor failed.\n",
            __FILE__,
            __LINE__
        );
        xme_hal_mem_set(desc, 0, sizeof(xme_core_exec_functionDescriptor_t));
        desc->task = (xme_hal_sched_taskCallback_t)
                &(xme_wp_udp_udpReceive_udpReceiveWayPointFunctionWrapper_execute);
        desc->taskArgs = desc;
        desc->componentId = componentId;
        desc->functionId = (xme_core_component_functionId_t) 1;
        desc->wcet_ns = xme_hal_time_timeIntervalFromMilliseconds(50);
        
        xme_core_exec_dispatcher_createFunctionExecutionUnit(desc, true);
        
        xme_wp_udp_udpReceive_init();
    }
    
    *descriptor = desc;
    
    return XME_STATUS_SUCCESS;
}

xme_status_t
udpReceiveWaypointAddConfig
(
    xme_core_exec_functionDescriptor_t* descriptor,
    xme_core_dataManager_dataPacketId_t* dataPort,
    uint8_t* key,
    uint32_t ipPort,
    xme_core_topic_t topic,
    uint16_t sizeOfTopic,
    xme_wp_waypoint_instanceId_t* instanceId,
    void* recvBuffer
)
{
    xme_status_t status;
    
    // Create publication
    {
        xme_core_attribute_descriptor_list_t metadata;
        xme_core_attribute_descriptor_t metadata_elements[1];
        metadata_elements[0].key = (xme_core_attribute_key_t) 0;
        metadata_elements[0].size = (size_t) 0;
        metadata.length = 1;
        metadata.element = metadata_elements;
    
        status = xme_core_dataHandler_createPort
        (
            descriptor->componentId,
            XME_CORE_COMPONENT_PORTTYPE_DCC_PUBLICATION,
            topic,
            sizeOfTopic,
            metadata,
            1,
            false,
            false,
            0,
            dataPort
        );
        XME_CHECK_MSG
        (
            XME_STATUS_SUCCESS == status,
            XME_STATUS_INTERNAL_ERROR,
            XME_LOG_ERROR,
            "%s:%d Creation of port failed.\n",
            __FILE__,
            __LINE__
        );
    }
    
    // Add waypoint configuration
    {
        uint16_t bufferSize;
        
        bufferSize = sizeOfTopic + xme_wp_udp_udpReceive_getPackageOverHead();
        
        recvBuffer = xme_hal_mem_alloc(bufferSize);
        XME_CHECK_MSG
        (
            NULL != recvBuffer,
            XME_STATUS_INTERNAL_ERROR,
            XME_LOG_ERROR,
            "%s:%d Allocation of buffer failed.\n",
            __FILE__,
            __LINE__
        );
        
        status = xme_wp_udp_udpReceive_addConfig
        (
            instanceId,
            *dataPort,
            sizeOfTopic,
            recvBuffer,
            bufferSize,
            key,
            ipPort
        );
        XME_CHECK_MSG
        (
            XME_STATUS_SUCCESS == status,
            XME_STATUS_INTERNAL_ERROR,
            XME_LOG_ERROR,
            "%s:%d udpReceive addConfig failed.\n",
            __FILE__,
            __LINE__
        );
    }
    
    // Register with broker
    status = xme_core_broker_registerFunction
    (
        descriptor->componentId,
        descriptor->functionId,
        (xme_core_component_functionVariantId_t)(*instanceId)
    );
    XME_CHECK_MSG
    (
        XME_STATUS_INVALID_PARAMETER != status && XME_STATUS_UNEXPECTED != status,
        status,
        XME_LOG_WARNING,
        "%s:%d Registeration with broker failed.\n",
        __FILE__,
        __LINE__
    );
    
    return XME_STATUS_SUCCESS;
}

void
destroyUdpReceiveWaypointInstance
(
    xme_core_exec_functionDescriptor_t* descriptor
)
{
    uint8_t i;
    
    // Free allocated buffers
    for (i = 0; i < sizeof(recvBuffers)/sizeof(recvBuffers[0]); i++)
    {
        xme_hal_mem_free(recvBuffers[i]);
    }
    
    xme_core_broker_removeFunction
    (
        descriptor->componentId,
        descriptor->functionId
    );
    xme_hal_mem_free(descriptor->initParam);
    xme_hal_mem_free(descriptor);
}

xme_status_t
createMarshalerWaypointInstance
(
    xme_core_exec_functionDescriptor_t** descriptor,
    xme_core_component_t componentId
)
{
    static xme_core_exec_functionDescriptor_t* desc = NULL;

    if (NULL == desc)
    {
        desc = (xme_core_exec_functionDescriptor_t*)
                xme_hal_mem_alloc(sizeof(xme_core_exec_functionDescriptor_t));
        XME_CHECK_MSG
        (
            NULL != desc,
            XME_STATUS_OUT_OF_RESOURCES,
            XME_LOG_ERROR,
            "%s:%d Allocation of function Descriptor failed.\n",
            __FILE__,
            __LINE__
        );
        xme_hal_mem_set(desc, 0, sizeof(xme_core_exec_functionDescriptor_t));
        desc->task = (xme_hal_sched_taskCallback_t)
                &(xme_wp_marshal_marshalerFunctionWrapper_execute);
        desc->taskArgs = desc;
        desc->componentId = componentId;
        desc->functionId = (xme_core_component_functionId_t) 1;
        desc->wcet_ns = xme_hal_time_timeIntervalFromMilliseconds(50);
        
        xme_core_exec_dispatcher_createFunctionExecutionUnit(desc, true);
        
        xme_wp_marshal_marshaler_init();
    }
    
    *descriptor = desc;
    
    return XME_STATUS_SUCCESS;
}

xme_status_t
marshalerWaypointAddConfig
(
    xme_core_exec_functionDescriptor_t* descriptor,
    xme_core_dataManager_dataPacketId_t* inputDataPort,
    xme_core_dataManager_dataPacketId_t* outputDataPort,
    xme_wp_waypoint_instanceId_t* instanceId,
    xme_core_topic_t topic,
    uint16_t topicSize
)
{
    xme_status_t status;
    
    // Create subscription port
    {
        xme_core_attribute_descriptor_list_t metadata;
        xme_core_attribute_descriptor_t metadata_elements[1];
        metadata_elements[0].key = (xme_core_attribute_key_t) 0;
        metadata_elements[0].size = (size_t) 0;
        metadata.length = 1;
        metadata.element = metadata_elements;
    
        status = xme_core_dataHandler_createPort
        (
            descriptor->componentId,
            XME_CORE_COMPONENT_PORTTYPE_DCC_SUBSCRIPTION,
            topic,
            topicSize,
            metadata,
            1,
            false,
            false,
            0,
            inputDataPort
        );
        XME_CHECK_MSG
        (
            XME_STATUS_SUCCESS == status,
            XME_STATUS_INTERNAL_ERROR,
            XME_LOG_ERROR,
            "%s:%d Creation of port failed.\n",
            __FILE__,
            __LINE__
        );
    }
    
    // Create publication port
    {
        xme_core_attribute_descriptor_list_t metadata;
        xme_core_attribute_descriptor_t metadata_elements[1];
        metadata_elements[0].key = (xme_core_attribute_key_t) 0;
        metadata_elements[0].size = (size_t) 0;
        metadata.length = 1;
        metadata.element = metadata_elements;
    
        status = xme_core_dataHandler_createPort
        (
            descriptor->componentId,
            XME_CORE_COMPONENT_PORTTYPE_DCC_PUBLICATION,
            topic,
            topicSize,
            metadata,
            1,
            false,
            false,
            0,
            outputDataPort
        );
        XME_CHECK_MSG
        (
            XME_STATUS_SUCCESS == status,
            XME_STATUS_INTERNAL_ERROR,
            XME_LOG_ERROR,
            "%s:%d Creation of port failed.\n",
            __FILE__,
            __LINE__
        );
    }
    
    // Add waypoint configuration
    {
        xme_wp_marshal_marshaler_addConfig
        (
            instanceId,
            topic,
            *inputDataPort,
            *outputDataPort
        );
    }
    
    // Register with broker
    status = xme_core_broker_registerFunction
    (
            descriptor->componentId,
            descriptor->functionId,
            (xme_core_component_functionVariantId_t)(*instanceId)
    );
    XME_CHECK_MSG
    (
        XME_STATUS_INVALID_PARAMETER != status || XME_STATUS_UNEXPECTED != status,
        status,
        XME_LOG_WARNING,
        "%s:%d Registeration with broker failed.\n",
        __FILE__,
        __LINE__
    );
    
    status = xme_core_broker_addDataPacketToFunction
    (
            *inputDataPort,
            descriptor->componentId,
            descriptor->functionId,
            (xme_core_component_functionVariantId_t)(*instanceId),
            true
    );
    XME_CHECK_MSG
    (
        XME_STATUS_INVALID_PARAMETER != status || XME_STATUS_UNEXPECTED != status,
        status,
        XME_LOG_WARNING,
        "%s:%d Addition of data packet to broker failed.\n",
        __FILE__,
        __LINE__
    );
    
    return XME_STATUS_SUCCESS;
}

void
destroyMarshalerWaypointInstance
(
    xme_core_exec_functionDescriptor_t* descriptor
)
{
    xme_core_broker_removeFunction
    (
        descriptor->componentId,
        descriptor->functionId
    );
    xme_hal_mem_free(descriptor->initParam);
    xme_hal_mem_free(descriptor);
}

xme_status_t
createUdpSendWaypointInstance
(
    xme_core_exec_functionDescriptor_t** descriptor,
    xme_core_component_t componentId
)
{
    static xme_core_exec_functionDescriptor_t* desc = NULL;

    if (NULL == desc)
    {
        desc = (xme_core_exec_functionDescriptor_t*)
                xme_hal_mem_alloc(sizeof(xme_core_exec_functionDescriptor_t));
        XME_CHECK_MSG
        (
            NULL != desc,
            XME_STATUS_OUT_OF_RESOURCES,
            XME_LOG_ERROR,
            "%s:%d Allocation of function Descriptor failed.\n",
            __FILE__,
            __LINE__
        );
        xme_hal_mem_set(desc, 0, sizeof(xme_core_exec_functionDescriptor_t));
        desc->task = (xme_hal_sched_taskCallback_t)
                &(xme_wp_udp_udpSend_udpSendWayPointFunctionWrapper_execute);
        desc->taskArgs = desc;
        desc->componentId = componentId;
        desc->functionId = (xme_core_component_functionId_t) 1;
        desc->wcet_ns = xme_hal_time_timeIntervalFromMilliseconds(50);
        
        xme_wp_udp_udpSend_init();
        
        xme_core_exec_dispatcher_createFunctionExecutionUnit(desc, true);
    }
    
    *descriptor = desc;
    
    return XME_STATUS_SUCCESS;
}

xme_status_t
udpSendWaypointAddConfig
(
    xme_core_exec_functionDescriptor_t* descriptor,
    xme_core_dataManager_dataPacketId_t* dataPort,
    uint8_t* key,
    const char* destIP,
    uint32_t ipPort,
    xme_core_topic_t topic,
    uint16_t sizeOfTopic,
    xme_wp_waypoint_instanceId_t* instanceId,
    void* sendBuffer,
    bool isBroadcast
)
{
    xme_status_t status;
    
    // Create subscription
    {
        xme_core_attribute_descriptor_list_t metadata;
        xme_core_attribute_descriptor_t metadata_elements[1];
        metadata_elements[0].key = (xme_core_attribute_key_t) 0;
        metadata_elements[0].size = (size_t) 0;
        metadata.length = 1;
        metadata.element = metadata_elements;
    
        status = xme_core_dataHandler_createPort
        (
            descriptor->componentId,
            XME_CORE_COMPONENT_PORTTYPE_DCC_SUBSCRIPTION,
            topic,
            sizeOfTopic,
            metadata,
            1,
            false,
            false,
            0,
            dataPort
        );
        XME_CHECK_MSG
        (
            XME_STATUS_SUCCESS == status,
            XME_STATUS_INTERNAL_ERROR,
            XME_LOG_ERROR,
            "%s:%d Creation of port failed.\n",
            __FILE__,
            __LINE__
        );
    }
    
    // Add waypoint configuration
    {
        uint16_t bufferSize;
        
        bufferSize = sizeOfTopic + xme_wp_udp_udpSend_getPackageOverHead();
        sendBuffer = xme_hal_mem_alloc(bufferSize);
        XME_CHECK_MSG
        (
            NULL != sendBuffer,
            XME_STATUS_INTERNAL_ERROR,
            XME_LOG_ERROR,
            "%s:%d Allocation of buffer failed.\n",
            __FILE__,
            __LINE__
        );
        
        status = xme_wp_udp_udpSend_addConfig
        (
            instanceId,
            *dataPort,
            sizeOfTopic,
            sendBuffer,
            bufferSize,
            key,
            destIP,
            ipPort,
            isBroadcast
        );
        XME_CHECK_MSG
        (
            XME_STATUS_SUCCESS == status,
            XME_STATUS_INTERNAL_ERROR,
            XME_LOG_ERROR,
            "%s:%d udpSend addConfig failed.\n",
            __FILE__,
            __LINE__
        );
    }
    
    // Register with broker
    status = xme_core_broker_registerFunction
    (
        descriptor->componentId,
        descriptor->functionId,
        (xme_core_component_functionVariantId_t)(*instanceId)
    );
    XME_CHECK_MSG
    (
        XME_STATUS_INVALID_PARAMETER != status && XME_STATUS_UNEXPECTED != status,
        status,
        XME_LOG_WARNING,
        "%s:%d Registeration with broker failed.\n",
        __FILE__,
        __LINE__
    );
    
    status = xme_core_broker_addDataPacketToFunction
    (
        *dataPort,
        descriptor->componentId,
        descriptor->functionId,
        (xme_core_component_functionVariantId_t)(*instanceId),
        true
    );
    XME_CHECK_MSG
    (
        XME_STATUS_INVALID_PARAMETER != status && XME_STATUS_UNEXPECTED != status,
        status,
        XME_LOG_WARNING,
        "%s:%d Addition of data packet to broker failed.\n",
        __FILE__,
        __LINE__
    );
    
    return XME_STATUS_SUCCESS;
}

void
destroyUdpSendWaypointInstance
(
    xme_core_exec_functionDescriptor_t* descriptor
)
{
    uint8_t i;
    
    
    // Free allocated buffers
    for (i = 0; i < sizeof(sendBuffers)/sizeof(sendBuffers[0]); i++)
    {
        xme_hal_mem_free(sendBuffers[i]);
    }
    xme_core_broker_removeFunction
    (
        descriptor->componentId,
        descriptor->functionId
    );
    xme_hal_mem_free(descriptor->initParam);
    xme_hal_mem_free(descriptor);
}


void
destroyFunction
(
    xme_core_exec_functionDescriptor_t* descriptor
)
{
    xme_core_broker_removeFunction
    (
        descriptor->componentId,
        descriptor->functionId
    );
    xme_hal_mem_free(descriptor->initParam);
    xme_hal_mem_free(descriptor);
}

void
addDataPacketTransferEntries(void)
{
    xme_core_broker_addDataPacketTransferEntry(ports[3], ports[0]); // demarshaler.configuration[0].out (guiComponent.writeText) -> guiComponent.writeText
    xme_core_broker_addDataPacketTransferEntry(ports[4], ports[2]); // udpReceive.configuration[0].out (guiComponent.writeText) -> demarshaler.configuration[0].in (guiComponent.writeText)
    xme_core_broker_addDataPacketTransferEntry(ports[1], ports[5]); // guiComponent.buttonPushed -> marshaler.configuration[0].in (guiComponent.buttonPushed)
    xme_core_broker_addDataPacketTransferEntry(ports[6], ports[7]); // marshaler.configuration[0].out (guiComponent.buttonPushed) -> udpSend.configuration[0].in (guiComponent.buttonPushed)
}

int
main(int argc, char* argv[])
{
    xme_status_t status;
    xme_core_exec_schedule_handle_t scheduleId;
    xme_core_exec_schedule_table_t* nodeSchedules[1];
    xme_core_exec_functionDescriptor_t* guiComponentWriteTextDesc = NULL;
    xme_core_exec_functionDescriptor_t* guiComponentSendButtonStateDesc = NULL;
    xme_core_exec_functionDescriptor_t* demarshalerWaypointDescriptor = NULL;
    xme_wp_waypoint_instanceId_t demarshalerWaypointInstanceIds[1];
    xme_core_exec_functionDescriptor_t* udpReceiveWaypointDescriptor = NULL;
    xme_wp_waypoint_instanceId_t udpReceiveWaypointInstanceIds[1];
    xme_core_exec_functionDescriptor_t* marshalerWaypointDescriptor = NULL;
    xme_wp_waypoint_instanceId_t marshalerWaypointInstanceIds[1];
    xme_core_exec_functionDescriptor_t* udpSendWaypointDescriptor = NULL;
    xme_wp_waypoint_instanceId_t udpSendWaypointInstanceIds[1];

    XME_UNUSED_PARAMETER(argc);
    XME_UNUSED_PARAMETER(argv);

    status = xmeInit();
    XME_CHECK_MSG
    (
        XME_STATUS_SUCCESS == status,
        status,
        XME_LOG_FATAL,
        "Error occurred during initialization of CHROMOSOME core components. Aborting execution."
    );
    
    // Create component instances
    
    // Component instance 'guiComponent' of type 'guiComponent'
    createGuiComponentInstance
    (
        (xme_core_component_t)1,
        &guiComponentWriteTextDesc,
        &guiComponentSendButtonStateDesc,
        &ports[0] // guiComponent.writeText
    );
    
    // Add waypoint configurations
    createDemarshalerWaypointInstance
    (
        &demarshalerWaypointDescriptor,
        (xme_core_component_t)2
    );
    
    {
        if (NULL != demarshalerWaypointDescriptor)
        {
            demarshalerWaypointAddConfig
            (
                demarshalerWaypointDescriptor,
                &ports[2], // demarshaler.configuration[0].in (guiComponent.writeText)
                &ports[3], // demarshaler.configuration[0].out (guiComponent.writeText)
                &demarshalerWaypointInstanceIds[0],
                CHROMOSOMEGUI_TOPIC_WRITETEXT,
                sizeof(chromosomeGui_topic_WriteText_t)
            );
        }
    }
    createUdpReceiveWaypointInstance
    (
        &udpReceiveWaypointDescriptor,
        (xme_core_component_t)3
    );
    
    {
        // Add configurations
        if (NULL != udpReceiveWaypointDescriptor)
        {
            {
                uint8_t key[] = {0, 0, 16, 3};
            
                udpReceiveWaypointAddConfig
                (
                    udpReceiveWaypointDescriptor,
                    &ports[4], // udpReceive.configuration[0].out (guiComponent.writeText)
                    key,
                    33221,
                    CHROMOSOMEGUI_TOPIC_WRITETEXT,
                    sizeof(chromosomeGui_topic_WriteText_t),
                    &udpReceiveWaypointInstanceIds[0],
                    recvBuffers[0]
                );
            }
        }
    }
    createMarshalerWaypointInstance
    (
        &marshalerWaypointDescriptor,
        (xme_core_component_t)4
    );
    
    {
        // Add configurations
        if (NULL != marshalerWaypointDescriptor)
        {
            marshalerWaypointAddConfig
            (
                marshalerWaypointDescriptor,
                &ports[5], // marshaler.configuration[0].in (guiComponent.buttonPushed)
                &ports[6], // marshaler.configuration[0].out (guiComponent.buttonPushed)
                &marshalerWaypointInstanceIds[0],
                CHROMOSOMEGUI_TOPIC_BUTTONSIGNAL,
                sizeof(chromosomeGui_topic_ButtonSignal_t)
            );
        }
    }
    createUdpSendWaypointInstance
    (
        &udpSendWaypointDescriptor,
        (xme_core_component_t)5
    );
    
    {
        // Add configurations
        if (NULL != udpSendWaypointDescriptor)
        {
            {
                uint8_t key[] = {0, 0, 16, 2};
            
                udpSendWaypointAddConfig
                (
                    udpSendWaypointDescriptor,
                    &ports[7], // udpSend.configuration[0].in (guiComponent.buttonPushed)
                    key,
                    "127.0.0.1",
                    33222,
                    CHROMOSOMEGUI_TOPIC_BUTTONSIGNAL,
                    sizeof(chromosomeGui_topic_ButtonSignal_t),
                    &udpSendWaypointInstanceIds[0],
                    sendBuffers[0],
                    false
                );
            }
        }
    }

    addDataPacketTransferEntries();

    // Execution Manager and Scheduler

    // Configure dispatcher
    if (NULL != guiComponentWriteTextDesc)
    {
        status = xme_core_exec_dispatcher_createFunctionExecutionUnit(guiComponentWriteTextDesc, true);
        XME_ASSERT(XME_STATUS_SUCCESS == status);
    }
    if (NULL != guiComponentSendButtonStateDesc)
    {
        status = xme_core_exec_dispatcher_createFunctionExecutionUnit(guiComponentSendButtonStateDesc, true);
        XME_ASSERT(XME_STATUS_SUCCESS == status);
    }

    // Configure schedule
    xme_core_exec_scheduler_createScheduleTable
    (
        &(nodeSchedules[0]),
        xme_hal_time_timeIntervalFromMilliseconds(1600)
    );

    if (NULL != guiComponentSendButtonStateDesc)
    {
        // Add function 'sendButtonState' of component instance 'guiComponent' of type 'guiComponent' to schedule
        status = xme_core_exec_scheduler_addElementToScheduleTable
        (
            nodeSchedules[0],
            guiComponentSendButtonStateDesc->componentId,
            guiComponentSendButtonStateDesc->functionId,
            guiComponentSendButtonStateDesc->taskArgs,
            xme_hal_time_timeIntervalFromSeconds(0),
            xme_hal_time_timeIntervalFromMilliseconds(200),
            1,
            0,
            true
        );
        XME_ASSERT(XME_STATUS_SUCCESS == status);
    }
    if (NULL != marshalerWaypointDescriptor)
    {
        // Add marshaler waypoint configuration for component port 'guiComponent.buttonPushed'to schedule
        status = xme_core_exec_scheduler_addElementToScheduleTable
        (
            nodeSchedules[0],
            marshalerWaypointDescriptor->componentId,
            marshalerWaypointDescriptor->functionId,
            (void *)(uintptr_t)marshalerWaypointInstanceIds[0],
            xme_hal_time_timeIntervalFromMilliseconds(200),
            xme_hal_time_timeIntervalFromMilliseconds(50),
            1,
            0,
            true
        );
        XME_ASSERT(XME_STATUS_SUCCESS == status);
    }
    if (NULL != udpSendWaypointDescriptor)
    {
        // Add udpsend waypoint configuration for component port 'guiComponent.buttonPushed'to schedule
        status = xme_core_exec_scheduler_addElementToScheduleTable
        (
            nodeSchedules[0],
            udpSendWaypointDescriptor->componentId,
            udpSendWaypointDescriptor->functionId,
            (void *)(uintptr_t)udpSendWaypointInstanceIds[0],
            xme_hal_time_timeIntervalFromMilliseconds(250),
            xme_hal_time_timeIntervalFromMilliseconds(50),
            1,
            0,
            true
        );
        XME_ASSERT(XME_STATUS_SUCCESS == status);
    }
    if (NULL != udpReceiveWaypointDescriptor)
    {
        // Add udpreceive waypoint configuration for component port 'guiComponent.writeText'to schedule
        status = xme_core_exec_scheduler_addElementToScheduleTable
        (
            nodeSchedules[0],
            udpReceiveWaypointDescriptor->componentId,
            udpReceiveWaypointDescriptor->functionId,
            (void *)(uintptr_t)udpReceiveWaypointInstanceIds[0],
            xme_hal_time_timeIntervalFromMilliseconds(300),
            xme_hal_time_timeIntervalFromMilliseconds(50),
            1,
            0,
            true
        );
        XME_ASSERT(XME_STATUS_SUCCESS == status);
    }
    if (NULL != demarshalerWaypointDescriptor)
    {
        // Add demarshaler waypoint configuration for component port 'guiComponent.writeText'to schedule
        status = xme_core_exec_scheduler_addElementToScheduleTable
        (
            nodeSchedules[0],
            demarshalerWaypointDescriptor->componentId,
            demarshalerWaypointDescriptor->functionId,
            (void *)(uintptr_t)demarshalerWaypointInstanceIds[0],
            xme_hal_time_timeIntervalFromMilliseconds(350),
            xme_hal_time_timeIntervalFromMilliseconds(50),
            1,
            0,
            true
        );
        XME_ASSERT(XME_STATUS_SUCCESS == status);
    }
    if (NULL != guiComponentWriteTextDesc)
    {
        // Add function 'writeText' of component instance 'guiComponent' of type 'guiComponent' to schedule
        status = xme_core_exec_scheduler_addElementToScheduleTable
        (
            nodeSchedules[0],
            guiComponentWriteTextDesc->componentId,
            guiComponentWriteTextDesc->functionId,
            guiComponentWriteTextDesc->taskArgs,
            xme_hal_time_timeIntervalFromMilliseconds(400),
            xme_hal_time_timeIntervalFromMilliseconds(200),
            1,
            0,
            true
        );
        XME_ASSERT(XME_STATUS_SUCCESS == status);
    }

    status = xme_core_exec_scheduler_registerSchedule(nodeSchedules[0], &scheduleId);
    XME_ASSERT(XME_STATUS_SUCCESS == status);

    // Activate schedule
    xme_core_exec_scheduler_activateSchedule(scheduleId);

    // Run the schedule
    xme_core_exec_run(0, false);
    xme_core_exec_fini();

    // Destroy waypoints
    if (NULL != demarshalerWaypointDescriptor)
    {
        destroyDemarshalerWaypointInstance(demarshalerWaypointDescriptor);
    }
    if (NULL != udpReceiveWaypointDescriptor)
    {
        destroyUdpReceiveWaypointInstance(udpReceiveWaypointDescriptor);
    }
    if (NULL != marshalerWaypointDescriptor)
    {
        destroyMarshalerWaypointInstance(marshalerWaypointDescriptor);
    }
    if (NULL != udpSendWaypointDescriptor)
    {
        destroyUdpSendWaypointInstance(udpSendWaypointDescriptor);
    }
    
    // Destroy components
    destroyFunction(guiComponentWriteTextDesc);
    destroyFunction(guiComponentSendButtonStateDesc);

    return 0;
}
