/*
 * Copyright (c) 2011-2013, fortiss GmbH.
 * Licensed under the Apache License, Version 2.0.
 *
 * Use, modification and distribution are subject to the terms specified
 * in the accompanying license file LICENSE.txt located at the root directory
 * of this software distribution. A copy is available at
 * http://chromosome.fortiss.org/.
 *
 * This file is part of CHROMOSOME.
 *
 * $Id: udpSend.c 4964 2013-09-04 12:50:18Z ruiz $
 */

/**
 * \file
 *
 * \brief  Waypoint that copies the data on UDP network transportation.
 *
 * \author
 *         This file has been generated by the CHROMOSOME Modeling Tool (fortiss GmbH).
 */

/******************************************************************************/
/***   Includes                                                             ***/
/******************************************************************************/
#include "xme/wp/udp/include/udpSend.h"
#include "xme/com/packet.h"

#include "xme/hal/include/mem.h"

#include <inttypes.h>

/******************************************************************************/
/***   Type definitions                                                     ***/
/******************************************************************************/
/**
 * \struct udpSendConfigItem_t
 *
 * \brief  Structure for storing a configuration for this waypoint.
 */
typedef struct
{
    xme_core_dataManager_dataPacketId_t dataId; ///< Port to read data from, which will be passed on the UDP socket.
    uint16_t sizeOfData; ///< Size of the data 
    void *buffer; ///< Buffer passed for writing the data to the network
    void *key; ///< The key which is added in the packet header to correctly identify the intended receipent.
    char* hostname; ///< Hostname to which data is to be sent
    uint16_t port; ///< Port of the given hostname to which data is to be sent
    xme_hal_net_socketHandle_t socketHandle; ///< The opened socket descriptor where data will be pumped.
} udpSendConfigItem_t;

/******************************************************************************/
/***   Static variables                                                     ***/
/******************************************************************************/
/**
 * \struct xme_wp_udp_udpSendConfigTable
 * \brief  Table for storing this waypoints configurations.
 */
static struct
{
    XME_HAL_TABLE( udpSendConfigItem_t, table, XME_WP_UDP_SEND_CONFIGURATIONTABLE_SIZE); ///< Table to store the waypoint configuration
    xme_hal_sync_criticalSectionHandle_t criticalSectionHandle; ///< Critical section handle for protecting critical regions.
} xme_wp_udp_udpSendConfigTable;

/******************************************************************************/
/***   Prototypes                                                           ***/
/******************************************************************************/

/**
 * \brief  Writes data to a specific interface.
 *
 *         The behavior is non-blocking writing; i.e. the function will
 *         copy the data of the buffer for sending and return immediately.
 *         The buffer can be reused right after the function call.
 *
 * \param  socketHandle Socket Handle where data is to be written.
 * \param  buffer       Data buffer Pointer which is to be written
 * \param  count        Count of the Data buffer.
 *
 * \return Returns the number of bytes that have been copied into the internal
 *         buffer. Might be zero if the internal buffer of the device is full.
 *         Returns 0 on error.
 */
uint16_t
xme_wp_udp_udpSend_write_non_blocking
(
    xme_hal_net_socketHandle_t socketHandle,
    const void *buffer,
    uint16_t count
);


/******************************************************************************/
/***   Implementation                                                       ***/
/******************************************************************************/
xme_status_t
xme_wp_udp_udpSend_init(void)
{
    XME_ASSERT(XME_ASSERT_NO_SIDE_EFFECTS(0 == XME_HAL_TABLE_ITEM_COUNT(xme_wp_udp_udpSendConfigTable.table)));
    XME_ASSERT(XME_HAL_SYNC_INVALID_CRITICAL_SECTION_HANDLE == xme_wp_udp_udpSendConfigTable.criticalSectionHandle);
    
    XME_HAL_TABLE_INIT(xme_wp_udp_udpSendConfigTable.table);

    XME_CHECK
    (
        XME_HAL_SYNC_INVALID_CRITICAL_SECTION_HANDLE != (xme_wp_udp_udpSendConfigTable.criticalSectionHandle = xme_hal_sync_createCriticalSection()),
        XME_STATUS_OUT_OF_RESOURCES
    );

    return XME_STATUS_SUCCESS;
}

xme_status_t
xme_wp_udp_udpSend_run
(
    xme_wp_waypoint_instanceId_t instanceId
)
{
    xme_status_t status;
    udpSendConfigItem_t *configurationItem;
    void* samplePayload;
    unsigned int bytesRead=0, bytesWritten;
    
    xme_hal_sync_enterCriticalSection(xme_wp_udp_udpSendConfigTable.criticalSectionHandle);
    configurationItem = XME_HAL_TABLE_ITEM_FROM_HANDLE(xme_wp_udp_udpSendConfigTable.table, (xme_hal_table_rowHandle_t) instanceId);
    xme_hal_sync_leaveCriticalSection(xme_wp_udp_udpSendConfigTable.criticalSectionHandle);

    XME_CHECK
    (
        NULL != configurationItem,
        XME_STATUS_INVALID_HANDLE
    );
    //Create the packet in the given buffer space
    XME_COM_PACKET_INIT(*(xme_com_packet_sample_header_t*)(configurationItem->buffer), XME_COM_PACKET_HEADER_TYPE_SAMPLE);
    //And copy the key
    xme_hal_mem_copy((void *)((xme_com_packet_sample_header_t*)(configurationItem->buffer))->key,(void *)configurationItem->key,XME_WP_UDP_HEADER_KEY_LENGTH);

    //Get the paylod from the packet
    samplePayload = XME_COM_PACKET_SAMPLE_PAYLOAD( configurationItem->buffer );

    // read from the dataId into the payload
    status = xme_core_dataHandler_readData(
            configurationItem->dataId,
            samplePayload,
            configurationItem->sizeOfData,
            &bytesRead
            );

    XME_CHECK
    (
        XME_STATUS_SUCCESS == status, 
        XME_STATUS_INTERNAL_ERROR
    );

    XME_CHECK
    (
        bytesRead == configurationItem->sizeOfData, 
        XME_STATUS_INTERNAL_ERROR
    );

    // send the data on the network
    bytesWritten = xme_wp_udp_udpSend_write_non_blocking( configurationItem->socketHandle, configurationItem->buffer, (bytesRead+(uint16_t)sizeof(xme_com_packet_sample_header_t)) );
    XME_CHECK
    (
        0 != bytesWritten, 
        XME_STATUS_INTERNAL_ERROR
    );

    //Complete the read operation before returning
    xme_core_dataHandler_completeReadOperation(configurationItem->dataId);
    
    return XME_STATUS_SUCCESS;
}

xme_status_t
xme_wp_udp_udpSend_getConfig
(
    xme_wp_waypoint_instanceId_t* instanceId,
    xme_core_dataManager_dataPacketId_t* dataId,
    void *key,
    const char* hostname,
    uint16_t port
)
{
    xme_hal_table_rowHandle_t handle = XME_HAL_TABLE_INVALID_ROW_HANDLE;
    udpSendConfigItem_t* configItem=NULL;

    XME_HAL_TABLE_GET_NEXT(xme_wp_udp_udpSendConfigTable.table,
                                    xme_hal_table_rowHandle_t, handle,
                                    udpSendConfigItem_t, configItem,
                                    ((xme_hal_mem_compare(configItem->hostname,hostname,strlen(hostname))==0) && configItem->port==port && xme_hal_mem_compare(configItem->key,key,XME_WP_UDP_HEADER_KEY_LENGTH)==0));
    if (XME_HAL_TABLE_INVALID_ROW_HANDLE!=handle)
    {
        //So his already exists, we dont have to add another entry we can return the same instance ID
        *instanceId = (xme_wp_waypoint_instanceId_t) handle;
        *dataId = configItem->dataId;
        return XME_STATUS_SUCCESS;
    }
    return XME_STATUS_NOT_FOUND;
}
xme_status_t
xme_wp_udp_udpSend_addConfig
(
    xme_wp_waypoint_instanceId_t* instanceId,
    xme_core_dataManager_dataPacketId_t dataId,
    uint16_t sizeOfData,
    void *buffer,
    uint16_t sizeOfBuffer,
    void* key,
    const char* hostname,
    uint16_t port,
    bool broadcast
)
{
    xme_hal_table_rowHandle_t configurationItemHandle;
    udpSendConfigItem_t* configurationItem;
    xme_status_t status;

    XME_CHECK
    (
        sizeOfBuffer>=(sizeOfData+(uint16_t)sizeof(xme_com_packet_sample_header_t)),
        XME_STATUS_INVALID_PARAMETER
    );

    {
        xme_hal_table_rowHandle_t exists = XME_HAL_TABLE_INVALID_ROW_HANDLE;
        udpSendConfigItem_t* existsItem=NULL;
        XME_HAL_TABLE_GET_NEXT(xme_wp_udp_udpSendConfigTable.table,
                                    xme_hal_table_rowHandle_t, exists,
                                    udpSendConfigItem_t, existsItem,
                                    ((xme_hal_mem_compare(existsItem->hostname,hostname,strlen(hostname))==0)
                                     && existsItem->port==port
                                     && xme_hal_mem_compare(existsItem->key,key,XME_WP_UDP_HEADER_KEY_LENGTH)==0));
        if (XME_HAL_TABLE_INVALID_ROW_HANDLE!=exists)
        {
            //So his already exists, we dont have to add another entry we can return the same instance ID
            *instanceId = (xme_wp_waypoint_instanceId_t)exists;
            return XME_STATUS_SUCCESS;
        }
    }

    xme_hal_sync_enterCriticalSection(xme_wp_udp_udpSendConfigTable.criticalSectionHandle);
    configurationItemHandle = XME_HAL_TABLE_ADD_ITEM(xme_wp_udp_udpSendConfigTable.table);
    xme_hal_sync_leaveCriticalSection(xme_wp_udp_udpSendConfigTable.criticalSectionHandle);

    XME_CHECK
    (
        XME_HAL_TABLE_INVALID_ROW_HANDLE != configurationItemHandle, 
        XME_STATUS_OUT_OF_RESOURCES
    );
    *instanceId = (xme_wp_waypoint_instanceId_t)configurationItemHandle;

    configurationItem = XME_HAL_TABLE_ITEM_FROM_HANDLE
    (
        xme_wp_udp_udpSendConfigTable.table, 
        configurationItemHandle
    );
    
    if (NULL == configurationItem)
    {
        return XME_STATUS_INTERNAL_ERROR;
    }

    configurationItem->hostname = (char *)xme_hal_mem_alloc(strlen(hostname)+1);
    xme_hal_safeString_strncpy(configurationItem->hostname,hostname,strlen(hostname)+1);
    configurationItem->key = (void *)xme_hal_mem_alloc(XME_WP_UDP_HEADER_KEY_LENGTH);
    xme_hal_mem_copy(configurationItem->key,key,XME_WP_UDP_HEADER_KEY_LENGTH);
    configurationItem->port = port;
    configurationItem->dataId = dataId;
    configurationItem->sizeOfData = sizeOfData;
    configurationItem->buffer = buffer;
    configurationItem->socketHandle = xme_hal_net_createSocket(
                            NULL,
                            (true == broadcast ? XME_HAL_NET_SOCKET_BROADCAST : 0x0 )|
                            XME_HAL_NET_SOCKET_UDP,
                            hostname,
                            port
                            );
    
    XME_CHECK_REC
    (
        (XME_HAL_NET_INVALID_SOCKET_HANDLE != configurationItem->socketHandle),
        XME_STATUS_OUT_OF_RESOURCES,
        {
            xme_hal_sync_enterCriticalSection(xme_wp_udp_udpSendConfigTable.criticalSectionHandle);
            XME_CHECK(XME_STATUS_SUCCESS == XME_HAL_TABLE_REMOVE_ITEM(xme_wp_udp_udpSendConfigTable.table, configurationItemHandle), XME_STATUS_INTERNAL_ERROR);
            xme_hal_sync_leaveCriticalSection(xme_wp_udp_udpSendConfigTable.criticalSectionHandle);
        }
    );

    status = xme_hal_net_openSocket( configurationItem->socketHandle );

    XME_CHECK_REC
    (
        (XME_STATUS_SUCCESS == status),
        XME_STATUS_OUT_OF_RESOURCES,
        {
            XME_CHECK(XME_STATUS_SUCCESS == xme_hal_net_destroySocket( configurationItem->socketHandle ), XME_STATUS_INTERNAL_ERROR);
            xme_hal_sync_enterCriticalSection(xme_wp_udp_udpSendConfigTable.criticalSectionHandle);
            XME_CHECK(XME_STATUS_SUCCESS == XME_HAL_TABLE_REMOVE_ITEM(xme_wp_udp_udpSendConfigTable.table, configurationItemHandle), XME_STATUS_INTERNAL_ERROR);
            xme_hal_sync_leaveCriticalSection(xme_wp_udp_udpSendConfigTable.criticalSectionHandle);
            
        }
    );

    return XME_STATUS_SUCCESS;
}

xme_status_t
xme_wp_udp_udpSend_fini(void)
{
    XME_HAL_TABLE_ITERATE_BEGIN
    (
        xme_wp_udp_udpSendConfigTable.table,
        xme_hal_table_rowHandle_t, configurationItemHandle,
        udpSendConfigItem_t, configurationItem
    );
    {
        XME_CHECK(XME_STATUS_SUCCESS == xme_hal_net_closeSocket( configurationItem->socketHandle ), XME_STATUS_INTERNAL_ERROR);
        XME_CHECK(XME_STATUS_SUCCESS == xme_hal_net_destroySocket( configurationItem->socketHandle ), XME_STATUS_INTERNAL_ERROR);
        xme_hal_mem_free(configurationItem->hostname);
        xme_hal_mem_free(configurationItem->key);
    }
    XME_HAL_TABLE_ITERATE_END();
    xme_hal_sync_destroyCriticalSection(xme_wp_udp_udpSendConfigTable.criticalSectionHandle);
    xme_wp_udp_udpSendConfigTable.criticalSectionHandle = XME_HAL_SYNC_INVALID_CRITICAL_SECTION_HANDLE;

    XME_HAL_TABLE_FINI(xme_wp_udp_udpSendConfigTable.table);

    return XME_STATUS_SUCCESS;
}

uint16_t
xme_wp_udp_udpSend_write_non_blocking
(
    xme_hal_net_socketHandle_t socketHandle,
    const void *buffer,
    uint16_t count
)
{
    xme_hal_net_setBlockingBehavior( socketHandle, false );

    return xme_hal_net_writeSocket(socketHandle, buffer, count );
}

uint16_t
xme_wp_udp_udpSend_getPackageOverHead(void)
{
    return (uint16_t)sizeof(xme_com_packet_sample_header_t);
}
