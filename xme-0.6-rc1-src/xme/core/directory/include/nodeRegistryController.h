/*
 * Copyright (c) 2011-2013, fortiss GmbH.
 * Licensed under the Apache License, Version 2.0.
 *
 * Use, modification and distribution are subject to the terms specified
 * in the accompanying license file LICENSE.txt located at the root directory
 * of this software distribution. A copy is available at
 * http://chromosome.fortiss.org/.
 *
 * This file is part of CHROMOSOME.
 *
 * $Id: nodeRegistryController.h 4997 2013-09-06 08:24:52Z ruiz $
 */

/**
 * \file
 *         Node Registry Controller.
 */

#ifndef XME_CORE_DIRECTORY_NODEREGISTRYCONTROLLER_H
#define XME_CORE_DIRECTORY_NODEREGISTRYCONTROLLER_H

/**
 * \defgroup core_directory_nodeRegistryController Node Registry Controller group. 
 * @{
 *
 * \brief Node Registry Controller registers all nodes attached to the network.
 *
 * \details The Node Registry Controller stores all associated informations
 *          related to nodes that belong to the Chromosome network. This information
 *          includes at least the node id and the random generated node unique identifier
 *          generated by the connected node.
 */

/******************************************************************************/
/***   Includes                                                             ***/
/******************************************************************************/
#include <stdint.h>

#include "xme/defines.h"

#include "xme/hal/include/graph.h"
#include "xme/hal/include/table.h"
#include "xme/com/interface.h"
#include "xme/core/node.h"
#include "xme/core/topic.h"

/******************************************************************************/
/***   Type definitions                                                     ***/
/******************************************************************************/

/**
 * \struct xme_core_directory_nodeRegistryController_nodeInterfaceIterator_s
 * \typedef xme_core_directory_nodeRegistryController_nodeInterfaceIterator_t
 * \brief The structure to store the node interface iterator.
 */
typedef struct xme_core_directory_nodeRegistryController_nodeInterfaceIterator_s
{
    xme_core_node_nodeId_t nodeId; ///< Node identifier of the node for which the iterator exists.
    xme_core_node_nodeData_t* nodeItem; ///< The nodeData pointer obtained from the node table (xme_core_directory_nodeRegistryController_nodeTable).
    xme_com_interface_addressType_t addressType; ///< Type of interface to iterate over.
    xme_hal_table_rowHandle_t currentHandle; ///< Current row handle till which we have iterated over in the interface table.
    xme_com_interface_address_t* interfaceItem; ///< Pointer to the interface entry to which the currentHandle points.
}
xme_core_directory_nodeRegistryController_nodeInterfaceIterator_t;

/******************************************************************************/
/***   Prototypes                                                           ***/
/******************************************************************************/
XME_EXTERN_C_BEGIN

/**
 * \brief initializes the node table
 * \return xme_status_t XME_STATUS_SUCCESS
 */
xme_status_t
xme_core_directory_nodeRegistryController_init(void);

/**
 * \brief frees the node table
 */
void
xme_core_directory_nodeRegistryController_fini(void);

/**
 * \brief adds the node to the node table
 * \param nodeId Id of the node to be added.
 * \param nodeName Name of the node to be added.
 * \param guid The target node generated id. 
 *
 * \return xme_status_t XME_STATUS_SUCCESS if the node gets successfully added.
 * \return xme_status_t XME_STATUS_INVALID_PARAMETER if the nodeId is invalid.
 * \return xme_status_t XME_STATUS_ALREADY_EXIST if the nodeId already exists.
 * \return xme_status_t XME_STATUS_OUT_OF_RESOURCES if the addition fails.
 */
xme_status_t
xme_core_directory_nodeRegistryController_registerNode
(
    xme_core_node_nodeId_t nodeId,
    const char* nodeName,
    xme_core_node_guid_t guid
);

/**
 * \brief Checks if a given guid is already registered in the node registry. 
 * \details Explores the internal node registry to check if the generated
 *          guid is already registered. 
 *
 * \param guid the generated id from requesting node.
 *
 * \retval true if the guid is already present in the node registry.
 * \retval false if the guid is not present in the node registry.
 */
bool
xme_core_directory_nodeRegistryController_isNodeGuidRegistered
(
    xme_core_node_guid_t guid
);

/**
 * \brief Gets the nodeID from a  given guid.
 * \details Explores the internal node registry to obtain the node id associated to
 *          the given guid. 
 *
 * \param guid the generated id from requesting node. 
 * \param nodeId Id of the node.
 *
 * \retval XME_STATUS_SUCCESS if the node id was successfully obtained.
 * \retval XME_STATUS_INVALID_PARAMETER if the provided guid is null-valued.
 * \retval XME_STATUS_NOT_FOUND if there are no instances in the node registry
 *         corresponding to the provided guid. 
 */
xme_status_t
xme_core_directory_nodeRegistryController_getNodeIdFromGUID
(
    xme_core_node_guid_t guid,
    xme_core_node_nodeId_t* nodeId
);

/**
 * \brief Gets the guid associated to a given nodeId.
 * \details Explores the internal node registry to obtain the guid associated to
 *          the given nodeid. 
 *
 * \param nodeId the assigned node id. 
 * \param guid requesting node generated unique identifier.
 *
 * \retval XME_STATUS_SUCCESS if the guid was successfully obtained.
 * \retval XME_STATUS_INVALID_PARAMETER if the provided nodeId is null-valued.
 * \retval XME_STATUS_NOT_FOUND if there are no instances in the node registry
 *         corresponding to the provided nodeId. 
 */
xme_status_t
xme_core_directory_nodeRegistryController_getGUIDFromNodeId
(
    xme_core_node_nodeId_t nodeId,
    xme_core_node_guid_t* guid
);

/**
 * \brief adds the interface to the node.
 *
 * \param nodeId Id of the node to be added.
 * \param interfaceAddress Address of the interface to be added
 *
 * \return xme_status_t XME_STATUS_SUCCESS if the interface gets successfully added to the give nodeId.
 * \return xme_status_t XME_STATUS_INVALID_PARAMETER if the nodeId is invalid.
 * \return xme_status_t XME_STATUS_NOT_FOUND if the nodeId does not exists.
 * \return xme_status_t XME_STATUS_OUT_OF_RESOURCES if the addition fails.
 */
xme_status_t
xme_core_directory_nodeRegistryController_addInterface
(
    xme_core_node_nodeId_t nodeId,
    xme_com_interface_address_t interfaceAddress
);

/**
 * \brief gets the interface to the node
 * \param nodeId Id of the node to be added.
 * \param addressType type of interface for which the address is to be returned
 * \param outInterface Pointer where the address of the interface to be returned.
 *
 * \return xme_status_t XME_STATUS_SUCCESS if the interface was found for the given nodeId.
 * \return xme_status_t XME_STATUS_INVALID_PARAMETER if the nodeId is invalid.
 * \return xme_status_t XME_STATUS_NOT_FOUND if the nodeId does not exists or the type of interface does not exists.
 */
xme_status_t
xme_core_directory_nodeRegistryController_getInterface
(
    xme_core_node_nodeId_t nodeId,
    xme_com_interface_addressType_t addressType, 
    xme_com_interface_address_t** outInterface
);

/**
 * \brief initializes the iterator of the interfaces of the node
 * \param nodeId Id of the node.
 * \param addressType type of interface which has to be iterated upon
 *        For all kinds of interfaces specify the type as XME_COM_INTERFACE_ADDRESS_TYPE_INVALID
 * \param iterator pointr to the iterator which has to be used for corresponding 
 *        xme_core_directory_node_nextInterface and xme_core_directory_node_hasNextInterface functions.
 *
 * \return xme_status_t XME_STATUS_SUCCESS if the iterator was successfully initialized
 * \return xme_status_t XME_STATUS_NOT_FOUND if the nodeId does not exists.
 * \return xme_status_t XME_STATUS_OUT_OF_RESOURCES if creation of iterator fails
 */
xme_status_t
xme_core_directory_nodeRegistryController_initNodeInterfaceIterator
(
    xme_core_node_nodeId_t nodeId, 
    xme_com_interface_addressType_t addressType, 
    xme_core_directory_nodeRegistryController_nodeInterfaceIterator_t **iterator
);

/**
 * \brief tells if there is another interface to iterate over.
 * \param iterator pointr to the iterator which was initialized using xme_core_directory_nodeRegistryController_initNodeInterfaceIterator
 *
 * \return bool true if there is a valid interface to be iterated over
 * \return bool false if there does not exist a valid interface or has invalid iterator
 */
bool
xme_core_directory_nodeRegistryController_hasNextInterface
(
    xme_core_directory_nodeRegistryController_nodeInterfaceIterator_t *iterator
);

/**
 * \brief gets the pointer to next interface in the iteration
 * \param iterator pointr to the iterator which was initialized using xme_core_directory_nodeRegistryController_initNodeInterfaceIterator
 *
 * \return xme_com_interface_address_t Pointer to the interface if it has valid iterator.
 *                                     NULL if the iterator is invalid
 */
xme_com_interface_address_t*
xme_core_directory_nodeRegistryController_nextInterface
(
    xme_core_directory_nodeRegistryController_nodeInterfaceIterator_t *iterator
);

/**
 * \brief releases the memory used by the iterator
 * \param iterator pointr to the iterator which was initialized using xme_core_directory_nodeRegistryController_initNodeInterfaceIterator
 *
 * \return xme_status_t XME_STATUS_SUCCESS if the free was called
 * \return xme_status_t XME_STATUS_INVALID_PARAMETER if the iterator was NULL
 */
xme_status_t
xme_core_directory_nodeRegistryController_finiNodeInterfaceIterator
(
    xme_core_directory_nodeRegistryController_nodeInterfaceIterator_t *iterator
);

XME_EXTERN_C_END

/**
 * @}
 */

#endif // #ifndef XME_CORE_DIRECTORY_NODEREGISTRYCONTROLLER_H
