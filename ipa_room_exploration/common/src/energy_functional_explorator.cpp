#include <ipa_room_exploration/energy_functional_explorator.h>

// Constructor
energyFunctionalExplorator::energyFunctionalExplorator()
{

}

// Function that computes the energy functional for each pair of nodes.
float energyFunctionalExplorator::E(const energyExploratorNode& location, const energyExploratorNode& neighbor,
		const std::set<cv::Point, cv_Point_cmp>& visited_nodes, const int cell_size, const double previous_travel_angle)
{
	float energy_functional = 0.0;

	// 1. translational distance
	cv::Point diff = location.center_ - neighbor.center_;
	energy_functional += cv::norm(diff)/cell_size;

	// 2. rotational distance
	double travel_angle_to_node = std::atan2(diff.y, diff.x);
	energy_functional += std::abs(previous_travel_angle - travel_angle_to_node)/PI_2;

	// 3. neighboring function, determining how many neighbors of the neighbor have been visited
	int visited_neighbors = 0;
	for(std::vector<energyExploratorNode*>::const_iterator n=neighbor.neighbors_.begin(); n!=neighbor.neighbors_.end(); ++n)
		if(visited_nodes.find((*n)->center_)!=visited_nodes.end())
			++visited_neighbors;
	energy_functional += 4 - visited_neighbors/2;

	return energy_functional;
}

// Function that plans a coverage path trough the given map, using the method proposed in
//
//	Bormann Richard, Joshua Hampp, and Martin HÃ¤gele. "New brooms sweep clean-an autonomous robotic cleaning assistant for
//	professional office cleaning." Robotics and Automation (ICRA), 2015 IEEE International Conference on. IEEE, 2015.
//
// This method discretizes the free space, that should be covered, into several nodes. Each of the node has to be covered, in order
// to cover the whole area. The path starts at the node that is closest to the given starting position and chooses the next node as
// the one that minimizes the energy functional, provided in the paper above. To do this here the following steps are done.
//	I.	The free area gets discretized into several nodes, using the given cell_size parameter, starting at the upper left white pixel of
//		the room. Whenever the overlaid grid then hits a white pixel, this point is added as a node. Then after all nodes have been found
//		the direct 8 neighbors for each node are found, which will be used later in the energy functional.
//	II.	After all nodes have been found, the coverage path is computed.
//			i.	The start node gets chosen as the one that is closest to the given starting position and is an edge of the given room, i.e
//				a node that has less than 4 neighbors.
//			ii.	The next node is then iteratively chosen from the directly neighboring ones, by finding the node that minimizes the given
//				energy functional and wasn't visited before.
//			iii.If in the neighborhood no accessible point could be found, search for the next node in the whole grid to continue the path.
//			iv.	This procedure is repeated, until all created nodes have been covered.
// III.	If wanted use the given vector from the robot middlepoint to the fow middlepoint to map the fow poses to the
//		robot footprint poses. To do so simply a vector transformation is applied. If the computed robot pose is not in the
//		free space, another accessible point is generated by finding it on the radius around the fow middlepoint s.t.
//		the distance to the last robot position is minimized. If this is not wanted one has to set the corresponding
//		Boolean to false (shows that the path planning should be done for the robot footprint).
//
void energyFunctionalExplorator::getExplorationPath(const cv::Mat& room_map, std::vector<geometry_msgs::Pose2D>& path, const float map_resolution,
			const cv::Point starting_position, const cv::Point2d map_origin, const float fitting_circle_radius,
			const bool plan_for_footprint, const Eigen::Matrix<float, 2, 1> robot_to_fow_vector)
{
	// *********************** I. Find the nodes and their neighbors ***********************
	// get the nodes in the free space
	std::vector<std::vector<energyExploratorNode> > nodes; // 2-dimensional vector to easily find the neighbors
	std::set<cv::Point, cv_Point_cmp> visited_nodes; // vector that stores the already visited nodes
	int radius_as_int = (int) std::floor(fitting_circle_radius);
	int number_of_nodes = 0;
	for(size_t y=0; y<room_map.rows; y+=2.0*radius_as_int)
	{
		// for the current row create a new set of neurons to span the network over time
		std::vector<energyExploratorNode> current_row;
		for(size_t x=0; x<room_map.cols; x+=2.0*radius_as_int)
		{
			// create node if the current point is in the free space
			energyExploratorNode current_node;
			current_node.center_ = cv::Point(x,y);
			if(room_map.at<uchar>(y,x) == 255)
			{
				current_node.obstacle_ = false;
				++number_of_nodes;
			}
			// add the obstacle nodes as already visited
			else
			{
				current_node.obstacle_ = true;
				++number_of_nodes;
				visited_nodes.insert(current_node.center_);
			}
			current_row.push_back(current_node);
		}

		// insert the current row into grid
		nodes.push_back(current_row);
	}
	std::cout << "found " << number_of_nodes <<  " nodes" << std::endl;

	// find the neighbors for each node
	std::vector<energyExploratorNode> corner_nodes; // vector that stores the corner nodes, i.e. nodes with 3 or less neighbors
	for(size_t row=0; row<nodes.size(); ++row)
	{
		for(size_t column=0; column<nodes[row].size(); ++column)
		{
			for(int dy=-1; dy<=1; ++dy)
			{
				// don't exceed the current row
				if(row+dy < 0 || row+dy >= nodes.size())
					continue;

				// get the neighbors left from the current neuron
				if(column > 0)
					nodes[row][column].neighbors_.push_back(&nodes[row+dy][column-1]);

				// get the nodes on the same column as the current neuron
				if(dy != 0)
					nodes[row][column].neighbors_.push_back(&nodes[row+dy][column]);

				// get the nodes right from the current neuron
				if(column < nodes[row].size()-1)
					nodes[row][column].neighbors_.push_back(&nodes[row+dy][column+1]);
			}

			// check if the current node is a corner, i.e. nodes that have 3 or less neighbors that are not obstacles
			int non_obstacle_neighbors = 0;
			for(std::vector<energyExploratorNode*>::iterator neighbor=nodes[row][column].neighbors_.begin(); neighbor!=nodes[row][column].neighbors_.end(); ++neighbor)
				if((*neighbor)->obstacle_==false)
					++non_obstacle_neighbors;

			if(non_obstacle_neighbors<=3 && nodes[row][column].obstacle_==false)
				corner_nodes.push_back(nodes[row][column]);
		}
	}
	std::cout << "found neighbors, corners: " << corner_nodes.size() << std::endl;

//	testing
//	for(size_t i=0; i<nodes.size(); ++i)
//	{
//		for(size_t j=0; j<nodes[i].size(); ++j)
//		{
//			cv::Mat test_map = room_map.clone();
//
//			std::vector<energyExploratorNode*> neighbors = nodes[i][j].neighbors_;
//			for(std::vector<energyExploratorNode*>::iterator n=neighbors.begin(); n!=neighbors.end(); ++n)
//				cv::circle(test_map, (*n)->center_, 2, cv::Scalar(127), CV_FILLED);
//
//			cv::imshow("neighbors", test_map);
//			cv::waitKey();
//		}
//	}

	// *********************** II. Plan the coverage path ***********************
	// i. find the start node of the path as a corner that is closest to the starting position
	energyExploratorNode start_node;
	float min_distance = 1e5;
	for(std::vector<energyExploratorNode>::iterator corner=corner_nodes.begin(); corner!=corner_nodes.end(); ++corner)
	{
		cv::Point diff = corner->center_ - starting_position;
		float current_distance = diff.x*diff.x+diff.y*diff.y;
		if(current_distance<=min_distance)
		{
			start_node = *corner;
			min_distance = current_distance;
		}
	}
	std::cout << "start: " << start_node.center_ << std::endl;

	// insert start node into coverage path
	std::vector<geometry_msgs::Pose2D> fow_coverage_path;
	geometry_msgs::Pose2D start_pose;
	start_pose.x = start_node.center_.x;
	start_pose.y = start_node.center_.y;
	fow_coverage_path.push_back(start_pose);

	// ii. starting at the start node, find the coverage path, by choosing the node that min. the energy functional
	energyExploratorNode last_node = start_node;
	visited_nodes.insert(start_node.center_);
	double previous_travel_angle = std::atan2(starting_position.y-start_node.center_.y, starting_position.x-start_node.center_.x);
	do
	{
		// check the direct neighbors, if at least one is not already visited
		std::vector<energyExploratorNode> not_visited_neighbors;
		for(std::vector<energyExploratorNode*>::iterator neighbor=last_node.neighbors_.begin(); neighbor!=last_node.neighbors_.end(); ++neighbor)
			if(visited_nodes.find((*neighbor)->center_)==visited_nodes.end())
				not_visited_neighbors.push_back(**neighbor);

		// if there are not visited direct neighbors, find the one of them that minimizes the energy functional
		if(not_visited_neighbors.size()>0)
		{
			// find best neighbor
			float min_energy = 1e4;
			energyExploratorNode next_node;
			for(std::vector<energyExploratorNode>::iterator candidate=not_visited_neighbors.begin(); candidate!=not_visited_neighbors.end(); ++candidate)
			{
				float current_energy = E(last_node, *candidate, visited_nodes, radius_as_int, previous_travel_angle);

				if(current_energy<min_energy)
				{
					min_energy = current_energy;
					next_node = *candidate;
				}
			}

			// add neighbor position to fow path and save the current robot location
			geometry_msgs::Pose2D current_pose;
			current_pose.x = next_node.center_.x;
			current_pose.y = next_node.center_.y;
			fow_coverage_path.push_back(current_pose);
			previous_travel_angle = std::atan2(last_node.center_.y-next_node.center_.y, last_node.center_.x-next_node.center_.x);
			last_node = next_node;
			visited_nodes.insert(next_node.center_);
		}
		// if no direct neighbor is unvisited, search for the next node in all unvisited nodes
		else
		{
			float min_energy = 1e4;
			energyExploratorNode next_node;

			// find best next node
			for(size_t row=0; row<nodes.size(); ++row)
			{
				for(size_t col=0; col<nodes[row].size(); ++col)
				{
					// only check free nodes and not visited ones
					if(nodes[row][col].obstacle_==false && visited_nodes.find(nodes[row][col].center_)==visited_nodes.end())
					{
						// check if current node has a better energy
						float current_energy = E(last_node, nodes[row][col], visited_nodes, radius_as_int, previous_travel_angle);
						if(current_energy<min_energy)
						{
							min_energy = current_energy;
							next_node = nodes[row][col];
						}
					}
				}
			}

			// add next node to path and set robot location
			geometry_msgs::Pose2D current_pose;
			current_pose.x = next_node.center_.x;
			current_pose.y = next_node.center_.y;
			fow_coverage_path.push_back(current_pose);
			previous_travel_angle = std::atan2(last_node.center_.y-next_node.center_.y, last_node.center_.x-next_node.center_.x);
			last_node = next_node;
			visited_nodes.insert(next_node.center_);
		}

//		std::cout << "covered nodes: " << visited_nodes.size() << std::endl;
	}while(visited_nodes.size()<number_of_nodes);

	// go trough the found fow-path and compute the angles of the poses s.t. it points to the next pose that should be visited
	for(unsigned int point_index=0; point_index<fow_coverage_path.size(); ++point_index)
	{
		// get the vector from the current point to the next point
		geometry_msgs::Pose2D current_point = fow_coverage_path[point_index];
		geometry_msgs::Pose2D next_point = fow_coverage_path[(point_index+1)%(fow_coverage_path.size())];

		float angle = std::atan2(next_point.y-current_point.y, next_point.x-current_point.x);

		// save the found angle
		fow_coverage_path[point_index].theta = angle;
	}

	// if the path should be planned for the footprint, transform the image points to the map coordinates
	if(plan_for_footprint==true)
	{
		for(std::vector<geometry_msgs::Pose2D>::iterator pose=fow_coverage_path.begin(); pose!=fow_coverage_path.end(); ++pose)
		{
			geometry_msgs::Pose2D current_pose;
			current_pose.x = (pose->x * map_resolution) + map_origin.x;
			current_pose.y = (pose->y * map_resolution) + map_origin.y;
			current_pose.theta = pose->theta;
			path.push_back(current_pose);
		}
		return;
	}

//	testing
//	cv::Mat path_map = room_map.clone();
//	cv::circle(path_map, cv::Point(fow_coverage_path[0].x, fow_coverage_path[0].y), 2, cv::Scalar(100), CV_FILLED);
//	std::cout << cv::Point(fow_coverage_path[0].x, fow_coverage_path[0].y) << std::endl;
//	for(std::vector<geometry_msgs::Pose2D>::iterator path_node=fow_coverage_path.begin()+1; path_node!=fow_coverage_path.end(); ++path_node)
//	{
//		cv::circle(path_map, cv::Point(path_node->x, path_node->y), 2, cv::Scalar(100), CV_FILLED);
//		cv::line(path_map, cv::Point(path_node->x, path_node->y), cv::Point((path_node-1)->x, (path_node-1)->y), cv::Scalar(127));
//		cv::imshow("path", path_map);
//		cv::waitKey();
//	}
//	cv::imshow("path", path_map);
//	cv::waitKey();

	// ****************** III. Map the found fow path to the robot path ******************
	mapPath(room_map, path, fow_coverage_path, robot_to_fow_vector, map_resolution, map_origin, starting_position);
}
